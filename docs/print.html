<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Molt Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="overview.html"><strong aria-hidden="true">1.</strong> Molt: More Or Less Tcl</a></li><li><ol class="section"><li><a href="tcl_comp.html"><strong aria-hidden="true">1.1.</strong> Tcl Compatibility</a></li></ol></li><li><a href="cmdline/cmdline.html"><strong aria-hidden="true">2.</strong> Molt Command Line Tool</a></li><li><ol class="section"><li><a href="cmdline/molt_shell.html"><strong aria-hidden="true">2.1.</strong> molt shell</a></li><li><a href="cmdline/molt_test.html"><strong aria-hidden="true">2.2.</strong> molt test</a></li><li><ol class="section"><li><a href="cmdline/test_commands/test.html"><strong aria-hidden="true">2.2.1.</strong> test</a></li></ol></li><li><a href="cmdline/molt_bench.html"><strong aria-hidden="true">2.3.</strong> molt bench</a></li><li><ol class="section"><li><a href="cmdline/bench_commands/benchmark.html"><strong aria-hidden="true">2.3.1.</strong> benchmark</a></li><li><a href="cmdline/bench_commands/measure.html"><strong aria-hidden="true">2.3.2.</strong> measure</a></li><li><a href="cmdline/bench_commands/ok.html"><strong aria-hidden="true">2.3.3.</strong> ok</a></li><li><a href="cmdline/bench_commands/ident.html"><strong aria-hidden="true">2.3.4.</strong> ident</a></li></ol></li></ol></li><li><a href="ref/reference.html"><strong aria-hidden="true">3.</strong> Molt Command Reference</a></li><li><ol class="section"><li><a href="ref/append.html"><strong aria-hidden="true">3.1.</strong> append</a></li><li><a href="ref/assert_eq.html"><strong aria-hidden="true">3.2.</strong> assert_eq</a></li><li><a href="ref/break.html"><strong aria-hidden="true">3.3.</strong> break</a></li><li><a href="ref/catch.html"><strong aria-hidden="true">3.4.</strong> catch</a></li><li><a href="ref/continue.html"><strong aria-hidden="true">3.5.</strong> continue</a></li><li><a href="ref/error.html"><strong aria-hidden="true">3.6.</strong> error</a></li><li><a href="ref/exit.html"><strong aria-hidden="true">3.7.</strong> exit</a></li><li><a href="ref/expr.html"><strong aria-hidden="true">3.8.</strong> expr</a></li><li><a href="ref/for.html"><strong aria-hidden="true">3.9.</strong> for</a></li><li><a href="ref/foreach.html"><strong aria-hidden="true">3.10.</strong> foreach</a></li><li><a href="ref/global.html"><strong aria-hidden="true">3.11.</strong> global</a></li><li><a href="ref/if.html"><strong aria-hidden="true">3.12.</strong> if</a></li><li><a href="ref/incr.html"><strong aria-hidden="true">3.13.</strong> incr</a></li><li><a href="ref/info.html"><strong aria-hidden="true">3.14.</strong> info</a></li><li><a href="ref/join.html"><strong aria-hidden="true">3.15.</strong> join</a></li><li><a href="ref/lindex.html"><strong aria-hidden="true">3.16.</strong> lindex</a></li><li><a href="ref/list.html"><strong aria-hidden="true">3.17.</strong> list</a></li><li><a href="ref/llength.html"><strong aria-hidden="true">3.18.</strong> llength</a></li><li><a href="ref/proc.html"><strong aria-hidden="true">3.19.</strong> proc</a></li><li><a href="ref/puts.html"><strong aria-hidden="true">3.20.</strong> puts</a></li><li><a href="ref/rename.html"><strong aria-hidden="true">3.21.</strong> rename</a></li><li><a href="ref/return.html"><strong aria-hidden="true">3.22.</strong> return</a></li><li><a href="ref/set.html"><strong aria-hidden="true">3.23.</strong> set</a></li><li><a href="ref/time.html"><strong aria-hidden="true">3.24.</strong> time</a></li><li><a href="ref/unset.html"><strong aria-hidden="true">3.25.</strong> unset</a></li><li><a href="ref/while.html"><strong aria-hidden="true">3.26.</strong> while</a></li></ol></li><li><a href="embed/overview.html"><strong aria-hidden="true">4.</strong> Extending and Embedding</a></li><li><ol class="section"><li><a href="embed/molt_value.html"><strong aria-hidden="true">4.1.</strong> The Molt Value Type</a></li><li><a href="embed/molt_result.html"><strong aria-hidden="true">4.2.</strong> The MoltResult Type</a></li><li><a href="embed/commands.html"><strong aria-hidden="true">4.3.</strong> Defining Commands</a></li><li><a href="embed/eval.html"><strong aria-hidden="true">4.4.</strong> Evaluating Molt Code</a></li><li><a href="embed/shell.html"><strong aria-hidden="true">4.5.</strong> Custom Shell Applications</a></li><li><a href="embed/library.html"><strong aria-hidden="true">4.6.</strong> Molt Library Crates</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Molt Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#molt-more-or-less-tcl" id="molt-more-or-less-tcl"><h1>Molt: More Or Less Tcl</h1></a>
<p>The goal of the Molt project is to create a &quot;small TCL&quot; interpreter for
embedding in Rust applications.  The word &quot;small&quot; is to be understood in
several senses:</p>
<ul>
<li><strong>Small in size.</strong> Embedding Molt shouldn't greatly increase the size of the
application.</li>
<li><strong>Small in language.</strong> <a href="http://tcl-lang.org">Standard TCL</a> has many features
intended for building entire software systems.  Molt is intentionally
limited to those needed for embedding.</li>
<li><strong>Small in dependencies.</strong> Building standard TCL is non-trivial.  Embedding
Molt should be as simple as using any other crate.</li>
</ul>
<p>Hence, perfect compatibility with standard TCL is explicitly not a goal.  Many
features will not be implemented at all (e.g., octal literals); and where a
clearly better alternative exists, others may be implemented somewhat
differently (e.g., <code>-nocomplain</code> will always be the normal behavior).</p>
<p>On the other hand, Molt is meant to be TCL (more or less), not simply a
&quot;Tcl-like language&quot;, so gratuitous differences are to be avoided.  One of the
goals of this document is to carefully delineate:</p>
<ul>
<li>The features that have not yet been implemented.</li>
<li>The features that likely will never be implemented.</li>
<li>Any small differences in behavior.</li>
<li>And especially, any features that have intentionally been implemented in
a different way.</li>
</ul>
<a class="header" href="#initial-goals" id="initial-goals"><h2>Initial Goals</h2></a>
<p>The initial goals are as follows; see <a href="./tcl_comp.html">Tcl Compatibility</a> for
more details.</p>
<ul>
<li>Embedding, script execution, and an interactive shell.
<ul>
<li>DONE</li>
</ul>
</li>
<li>Parse to internal form, rather than reparsing strings at execution a la TCL 7.6
<ul>
<li>And eventually, some kind of byte-compilation.</li>
<li>IN PROGRESS.  Scripts are parsed to internal form, which is cached for later
evaluation; Expressions are not.</li>
</ul>
</li>
<li>Support for lists and dicts
<ul>
<li>IN PROGRESS.  Lists exist but not all list commands are implemented.  Dicts do not
currently exist.</li>
</ul>
</li>
<li>A minimal set of commands</li>
<li>Procs
<ul>
<li>IN PROGRESS.  Optimization is needed.</li>
</ul>
</li>
<li>Expressions
<ul>
<li>IN PROGRESS.  Not all math functions are supported, and the parsing/evaluation needs
optimization.</li>
</ul>
</li>
<li><a href="./cmdline/molt_test.html"><strong>molt test</strong></a>, a simple test harness for Molt
code.
<ul>
<li>Along with a thorough test suite, using <code>cargo test</code> for the internals
and <code>molt test</code> for the language.</li>
<li>IN PROGRESS. The test tool exists; more tests are needed.</li>
</ul>
</li>
<li>Modular: pay for what you need
<ul>
<li>I.e. don't require a large regex library for all clients.</li>
<li>But allow it to be added as needed.</li>
</ul>
</li>
<li>Configurable command sets
<ul>
<li>The embedding API should allow the client to easily control the set of
commands included in an interpreter.  For example, a game engine might
want to exclude <code>proc</code>, <code>source</code>, <code>eval</code>, etc.</li>
</ul>
</li>
<li>Stack traces
<ul>
<li>Standard TCL provides detailed error stack traces.  Molt should do the
same, but probably not in the same fashion.</li>
</ul>
</li>
</ul>
<a class="header" href="#tcl-compatibility" id="tcl-compatibility"><h1>Tcl Compatibility</h1></a>
<p>The initial version of Molt is aiming at compatibility with TCL 7.6, the
last version not to be byte-compiled (with a few TCL 8-based additions).
Once the basic interpreter and command set is in place, along with a thorough
test suite (based on TCL's own), the plan is to begin to optimize for speed.</p>
<p>Each <a href="./ref/reference.html">command's man page</a> in this book documents any
temporary or permanent differences between it and the similarly named command
in <a href="http://tcl-lang.org">Standard TCL</a>.</p>
<p>The remainder of this section documents overall differences; see the
<a href="https://github.com/wduquette/molt">Molt README</a> for details on current
development.</p>
<p>Note that if the modular design is done properly, some of the features
described as never to be implemented could be added as extension crates.</p>
<a class="header" href="#features-that-already-exist" id="features-that-already-exist"><h2>Features that already exist</h2></a>
<p>See the <a href="./ref/reference.html">command reference</a> for the set of commands that
have already been implemented.  The current set of features includes:</p>
<ul>
<li>Script execution</li>
<li>Procedure definition</li>
<li>Control flow</li>
<li>Molt Values (e.g., Tcl_Obj)</li>
<li>Local and global variables (but not arrays)</li>
<li>Evaluation of expressions</li>
<li>A modicum of introspection</li>
<li>An interactive REPL
<ul>
<li>Using the <code>rustyline</code> crate for line editing.</li>
</ul>
</li>
<li>Execution of script files</li>
<li>A test harness</li>
<li>The beginnings of a detailed test suite</li>
</ul>
<a class="header" href="#features-to-be-added-soon" id="features-to-be-added-soon"><h2>Features to be added soon</h2></a>
<ul>
<li>An improved test suite</li>
<li>Additional commands from the minimal TCL command set:</li>
<li>A clean and modular embedding API
<ul>
<li>Including interactive REPLs, and the ability to use
<code>molt test</code> to test custom Molt extensions.</li>
</ul>
</li>
</ul>
<a class="header" href="#features-to-be-added-later" id="features-to-be-added-later"><h2>Features to be added later</h2></a>
<ul>
<li>Array variables (associative arrays)</li>
<li>Dictionaries</li>
<li>Globs and Regexes</li>
<li>Byte Compilation</li>
</ul>
<a class="header" href="#features-that-may-never-be-added" id="features-that-may-never-be-added"><h2>Features that may never be added</h2></a>
<ul>
<li>Namespaces</li>
<li>Slave interpreters</li>
<li>Traces</li>
<li>File I/O</li>
<li>Event loop</li>
</ul>
<a class="header" href="#features-that-will-almost-certainly-never-be-added" id="features-that-will-almost-certainly-never-be-added"><h2>Features that will almost certainly never be added</h2></a>
<ul>
<li>The TCL autoloader</li>
<li>Packages/TCL Modules
<ul>
<li>Though some form of module architecture might become valuable at
some point.</li>
</ul>
</li>
<li>Coroutines</li>
<li>Communication between Interps in different threads</li>
<li>Support for dynamic libraries</li>
<li>Support for binary extensions written in C (or anything but Rust)</li>
<li>Network I/O</li>
<li>OOP</li>
</ul>
<a class="header" href="#miscellaneous-differences" id="miscellaneous-differences"><h2>Miscellaneous Differences</h2></a>
<p>See the man pages for specific commands for other differences.</p>
<ul>
<li>Integer literals beginning with &quot;0&quot; are NOT assumed to be octal.
Nor will they ever be.</li>
<li>The encoding is currently always UTF-8.</li>
<li>In <code>$name</code>, the name may include underscores and any character that
Rust considers to be alphanumeric.</li>
<li>The notion of what constitutes whitespace is generally left up to Rust.</li>
<li>When using the TCL shell interactively, TCL will attempt to match
partial names of commands and subcommands as a convenience.  Molt does not.
<ul>
<li>In principle, some form of tab-completion could be added at some point.</li>
</ul>
</li>
</ul>
<a class="header" href="#molt-command-line-tool" id="molt-command-line-tool"><h1>Molt Command Line Tool</h1></a>
<p>The <code>molt-app</code> crate provides a command line tool for use in development and
experimentation. The command line tool, called <code>molt</code>, has two subcommands:</p>
<p><a href="cmdline/./molt_shell.html"><strong>molt shell</strong></a> executes scripts and provides an
interactive REPL.</p>
<p><a href="cmdline/./molt_test.html"><strong>molt test</strong></a> executes Molt test suites, most notably
Molt's own test suite.</p>
<p>Note: the <code>molt-shell</code> crate provides the same features for use with customized Molt interpreters.</p>
<a class="header" href="#molt-shell-script-args" id="molt-shell-script-args"><h1>molt shell ?<em>script</em>? ?<em>args...</em>?</h1></a>
<p>The <code>molt shell</code> command invokes the Molt interpreter.</p>
<a class="header" href="#interactive-use" id="interactive-use"><h2>Interactive Use</h2></a>
<p>When called without any arguments, the command invokes the interactive interpreter:</p>
<pre><code class="language-tcl">$ molt shell
Molt 0.1.0
%
</code></pre>
<p>Molt commands may be entered at the <code>%</code> prompt.  Enter <code>exit</code> to leave the interpreter.</p>
<a class="header" href="#script-execution" id="script-execution"><h2>Script Execution</h2></a>
<p>When called with arguments, the first argument is presumed to be the name of a Molt script;
any subsequent arguments are passed to the script.</p>
<pre><code class="language-tcl">$ molt shell my_script.tcl arg1 arg2 arg3
...
$
</code></pre>
<p>When called in this way, the variable <strong>arg0</strong> contains the name of the script, and the
variable <strong>argv</strong> contains a list of the additional arguments (if any).</p>
<p>For example, consider the following script, <code>args.tcl</code>:</p>
<pre><code class="language-tcl">puts &quot;arg0 = $arg0&quot;
puts &quot;argv = $argv&quot;
</code></pre>
<p>This script may be run as follows</p>
<pre><code class="language-tcl">$ molt shell args.tcl a b c
arg0 = args.tcl
argv = a b c
$
</code></pre>
<a class="header" href="#molt-test-filename-args" id="molt-test-filename-args"><h1>molt test <em>filename</em> ?<em>args...</em>?</h1></a>
<p>This command executes the test script called <em>filename</em> using the Molt
test harness, which is similar to Standard TCL's <code>tcltest</code> framework (though
much simpler, at present). Any arguments are passed to the test harness
(which ignores them, at present).</p>
<a class="header" href="#test-suites" id="test-suites"><h2>Test Suites</h2></a>
<p><code>molt test</code> is often used to execute an entire test suite, spread over
multiple files.  To simplify writing such a suite, <code>molt test</code> assumes
that the folder contain the specified <em>filename</em> is the base folder for
the test suite, and sets the current working directory to that folder.
This allows the named test script to use <a href="cmdline/../ref/source.html"><strong>source</strong></a> to
load other test scripts using paths relative to its own location.</p>
<a class="header" href="#writing-tests" id="writing-tests"><h2>Writing Tests</h2></a>
<p>Tests are written using the <a href="cmdline/../ref/test.html"><strong>test</strong></a> command.  See
that man page for examples.</p>
<a class="header" href="#running-tests" id="running-tests"><h2>Running Tests</h2></a>
<p>For example,</p>
<pre><code class="language-tcl">$ molt test good_tests.tcl
molt 0.1.0 -- Test Harness

5 tests, 5 passed, 0 failed, 0 errors
$ molt test bad_tests.tcl
molt 0.1.0 -- Test Harness

*** FAILED mytest-1.1 some proc
Expected -ok &lt;this result&gt;
Received -ok &lt;that result&gt;

2 tests, 1 passed, 1 failed, 0 errors
</code></pre>
<a class="header" href="#test-name-description-args-" id="test-name-description-args-"><h1>test <em>name</em> <em>description</em> <em>args ...</em></h1></a>
<p><strong>Available in <a href="cmdline/test_commands/../molt_test.html"><strong>molt test</strong></a> scripts only!</strong></p>
<p>The <code>test</code> command is used to test Molt commands, whether built-in or coded
in Molt.  It executes a Molt script, and compares the result against an
expected value, which may be an <code>-ok</code> result or an <code>-error</code> message.</p>
<p>The <em>name</em> and <em>description</em> are used to identify the test in the output.  The
<em>name</em> can be any string, but the convention is to use the format
&quot;<em>baseName</em>-<em>x</em>.<em>y</em>&quot;, e.g., <code>mycommand-1.1</code>.  In the future, <code>molt test</code>
will allow the user to filter the set of tests on this name string.</p>
<p>The test is executed in its own local variable scope; variables used by the
test will be cleaned up automatically at the end of the test.  The
<a href="cmdline/test_commands/../../ref/global.html"><strong>global</strong></a> command may be used to reference global variables; however,
changes to these must be cleaned up explicitly.</p>
<p>The <code>test</code> command has two forms, a brief form and an extended form with more options.</p>
<a class="header" href="#test-name-description-body--ok-error-expectedvalue" id="test-name-description-body--ok-error-expectedvalue"><h2>test <em>name</em> <em>description</em> <em>body</em> -ok|-error <em>expectedValue</em></h2></a>
<p>In the brief form, the <em>body</em> is the test script itself; and it is expected to return
a normal result or an error message.  Either way, <em>expectedValue</em> is the expected value.</p>
<ul>
<li>The test <strong>passes</strong> if the <em>body</em> returns the right kind of result with the expected value.</li>
<li>The test <strong>fails</strong> if the <em>body</em> returns the right kind of result (e.g., <code>-ok</code>) with
some other value.</li>
<li>The test is in <strong>error</strong> if the <em>body</em> returns the wrong kind of result, (e.g., an
error was returned when a normal result was expected).</li>
</ul>
<a class="header" href="#test-name-description-option-value-option-value-" id="test-name-description-option-value-option-value-"><h2>test <em>name</em> <em>description</em> <em>option value</em> ?<em>option value ...</em>?</h2></a>
<p>In the extended form, the details of the test are specified using options:</p>
<ul>
<li>
<p><strong>-setup</strong>: indicates a setup script, which will be executed before the body of the
test.  The test is flagged as an <strong>error</strong> if the setup script returns anything
but a normal result.</p>
</li>
<li>
<p><strong>-body</strong>: indicates the test's <em>body</em>, which is interpreted as in the brief form.</p>
</li>
<li>
<p><strong>-cleanup</strong>: indicates a cleanup script, which will be executed after the body of the
test.  The test is flagged as an <strong>error</strong> if the setup script returns anything but
a normal result.</p>
</li>
<li>
<p><strong>-ok | -error</strong>: indicates the expected value, as in the brief form.</p>
</li>
</ul>
<a class="header" href="#examples" id="examples"><h2>Examples</h2></a>
<p>The following tests are for an imaginary <code>square</code> command that returns the square
of a number.  They use the brief form.</p>
<pre><code class="language-Tcl">test square-1.1 {square errors} {
    square
} -error {wrong # args: should be &quot;square number&quot;}

test square-2.1 {square command} {
    square 3
} -ok {9}
</code></pre>
<p>The following test shows the extended form:</p>
<pre><code class="language-Tcl">test newproc-1.1 {new proc} -setup {
    # Define a proc for use in the test
    proc myproc {} { return &quot;called myproc&quot; }
} -body {
    # Call the proc
    myproc
} -cleanup {
    # Clean up the proc
    rename myproc &quot;&quot;
} -error {called myproc}
</code></pre>
<a class="header" href="#tcl-notes" id="tcl-notes"><h2>TCL Notes</h2></a>
<p>This command is a simplified version of the <code>test</code> command defined by
Standard TCL's <code>tcltest(n)</code> framework.  The intention is to increase the
similarity over time.</p>
<p>This command has an enhancement over TCL's <code>test</code> command: the test has
its own local variable scope, just as a <a href="cmdline/test_commands/../../ref/proc.html"><strong>proc</strong></a> does.  The body
must use the <a href="cmdline/test_commands/../../ref/global.html"><strong>global</strong></a> command to access global variables.</p>
<a class="header" href="#molt-bench-filename--csv" id="molt-bench-filename--csv"><h1>molt bench <em>filename</em> ?-csv?</h1></a>
<p>This command executes the benchmark script called <em>filename</em> using the Molt benchmark
framework. The framework runs the benchmarks in the script and outputs the results in
microseconds.</p>
<pre><code class="language-console">$ molt bench benchmarks/basic.tcl
Molt 0.1.0 -- Benchmark

  Micros     Norm -- Benchmark
    0.90     1.00 -- ok-1.1 ok, no arguments
    1.05     1.16 -- ok-1.2 ok, one argument
    1.51     1.67 -- ok-1.2 ok, two arguments
    1.23     1.36 -- ident-1.1 ident, simple argument
    1.46     1.61 -- incr-1.1 incr a
...
$
</code></pre>
<p>The <code>Norm</code> column shows the times relative to the first benchmark in the set.</p>
<a class="header" href="#csv-output" id="csv-output"><h2>CSV Output</h2></a>
<p>Use the <code>-csv</code> option to produce output in CSV format:</p>
<pre><code class="language-console">$ molt bench benchmarks/basic.tcl -csv
&quot;benchmark&quot;,&quot;description&quot;,&quot;micros&quot;,&quot;norm&quot;
&quot;ok-1.1&quot;,&quot;ok, no arguments&quot;,0.749,1
&quot;ok-1.2&quot;,&quot;ok, one argument&quot;,1.092,1.457943925233645
&quot;ok-1.2&quot;,&quot;ok, two arguments&quot;,1.509,2.014686248331108
&quot;ident-1.1&quot;,&quot;ident, simple argument&quot;,1.276,1.7036048064085447
&quot;incr-1.1&quot;,&quot;incr a&quot;,1.462,1.9519359145527369
...
</code></pre>
<a class="header" href="#writing-benchmarks" id="writing-benchmarks"><h2>Writing Benchmarks</h2></a>
<p>Benchmarks are written using the <a href="cmdline/./bench_commands/benchmark.html"><strong>benchmark</strong></a> or
<a href="cmdline/./bench_commands/measure.html"><strong>measure</strong></a> commands.  See those man pages for examples.</p>
<a class="header" href="#benchmark-name-description-body-count" id="benchmark-name-description-body-count"><h1>benchmark <em>name</em> <em>description</em> <em>body</em> ?<em>count</em>?</h1></a>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>Defines a benchmark with the given name and description.  The <em>body</em> is a Tcl script; it is executed <em>count</em> times via the <a href="cmdline/bench_commands/../../ref/time.html"><strong>time</strong></a> command, and records the average runtime in microseconds.  The count defaults to 1000 iterations.</p>
<p>The <em>name</em> should be a symbolic name for easy searching; the <em>description</em> should be a
brief human-readable description of the benchmark.</p>
<a class="header" href="#example" id="example"><h2>Example</h2></a>
<p>The following is a simple benchmark of the <a href="cmdline/bench_commands/../../ref/incr.html"><strong>incr</strong></a> command.</p>
<pre><code class="language-tcl">benchmark incr-1.1 {incr a} {
    incr a
}
</code></pre>
<a class="header" href="#measure-name-description-micros" id="measure-name-description-micros"><h1>measure <em>name</em> <em>description</em> <em>micros</em></h1></a>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>This is a low-level command used by the <a href="cmdline/bench_commands/./benchmark.html"><strong>benchmark</strong></a> command
to record measurements.  All recorded measurements will be included in the tool's
output.</p>
<p>Benchmark scripts won't usually need to call this; however, it can
be useful when defining custom benchmarking commands.</p>
<a class="header" href="#example-1" id="example-1"><h2>Example</h2></a>
<pre><code class="language-tcl">measure incr-1.1 &quot;incr a&quot; 1.46
</code></pre>
<a class="header" href="#ok-arg-arg" id="ok-arg-arg"><h1>ok ?<em>arg</em> <em>arg</em>...?</h1></a>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>This command takes any number of arguments and returns the empty string.  It is useful when benchmarking code that calls other commands, as (with no arguments) it represents the minimum
amount of computation the Molt interpreter can do.</p>
<a class="header" href="#example-2" id="example-2"><h2>Example</h2></a>
<p>For example, Molt's own benchmark suite includes the following as its baseline, as a lower bound on the run-time of evaluating a script:</p>
<pre><code class="language-tcl">benchmark ok-1.1 {ok, no arguments} {
    ok
}
</code></pre>
<a class="header" href="#ident-value" id="ident-value"><h1>ident <em>value</em></h1></a>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>Returns its argument unchanged.  Like <a href="cmdline/bench_commands/./ok.html"><strong>ok</strong></a>, this is a command used for
constructing benchmarks of the Molt interpreter itself.</p>
<a class="header" href="#molt-command-reference" id="molt-command-reference"><h1>Molt Command Reference</h1></a>
<p>Molt implements the following commands.  See the reference for each
command to see any differences from Standard TCL.</p>
<a class="header" href="#append-varname-value-" id="append-varname-value-"><h1>append <em>varName</em> ?<em>value</em> ...?</h1></a>
<p>Appends zero or more values to the value of variable <em>varName</em>.
If <em>varName</em> didn't previously exist, it is set to the concatenation
of the values.</p>
<a class="header" href="#examples-1" id="examples-1"><h2>Examples</h2></a>
<pre><code class="language-Tcl">set x &quot;this&quot;
append x &quot;that&quot;
assert_eq $x &quot;thisthat&quot;

append y a b c
assert_eq $y abc
</code></pre>
<a class="header" href="#assert_eq-received-expected" id="assert_eq-received-expected"><h1>assert_eq <em>received</em> <em>expected</em></h1></a>
<p>Asserts that the string <em>received</em> equals the string <em>expected</em>.  On success,
returns the empty string; on failure, returns an error.</p>
<p>This command is primarily intended for use in examples, to show the expected
result of a computation, rather than for use in test suites.  For testing,
see the <a href="ref/./test.html"><code>test</code></a> command and the
<a href="ref/../cmdline/molt_test.html"><code>molt test</code></a> tool.</p>
<a class="header" href="#tcl-notes-1" id="tcl-notes-1"><h2>TCL Notes</h2></a>
<p>This command is not part of Standard TCL; it is provided because of its
similarity to the Rust <code>assert_eq!</code> macro.</p>
<a class="header" href="#break" id="break"><h1>break</h1></a>
<p>Breaks execution of the inmost loop containing the <code>break</code> command,
continuing execution after the loop.</p>
<a class="header" href="#example-3" id="example-3"><h2>Example</h2></a>
<pre><code class="language-Tcl">foreach item $list {
    ...
    if {[someCondition]} {
        break
    }
    ...
}

# Execution continues here after the break
</code></pre>
<a class="header" href="#catch-script-resultvarname" id="catch-script-resultvarname"><h1>catch <em>script</em> ?<em>resultVarName</em>?</h1></a>
<p>Executes the script, catching the result, including any errors.  The return value of <code>catch</code>
is an integer code that indicates why the script returned.  If given, the variable called
<em>resultVarName</em> in the caller's scope is set to the actual return value.</p>
<p>There are five return codes:</p>
<table><thead><tr><th> Return Code  </th><th> Effect </th></tr></thead><tbody>
<tr><td> 0 (normal)   </td><td> Normal. The result variable is set to the script's result. </td></tr>
<tr><td> 1 (error)    </td><td> A command in the script threw an error. The result variable is set to the error message. </td></tr>
<tr><td> 2 (return)   </td><td> The script called <a href="ref/./return.html"><strong>return</strong></a> The result variable is set to the returned value. </td></tr>
<tr><td> 3 (break)    </td><td> The script called <a href="ref/./break.html"><strong>break</strong></a>. </td></tr>
<tr><td> 4 (continue) </td><td> The script called <a href="ref/./continue.html"><strong>continue</strong></a>. </td></tr>
</tbody></table>
<a class="header" href="#example-4" id="example-4"><h2>Example</h2></a>
<p><code>catch</code> is most often used to catch errors.  For example,</p>
<pre><code class="language-tcl">if {[catch {do_something} result]} {
    puts &quot;Error result: $result&quot;
} else {
    puts &quot;Good result: $result&quot;
}
</code></pre>
<a class="header" href="#tcl-liens" id="tcl-liens"><h2>TCL Liens</h2></a>
<p>In Standard TCL, the <code>catch</code> command has an additional argument, a variable that receives a
dictionary with full details about the context of the returned value.  Molt doesn't yet
implement this mechanism.</p>
<a class="header" href="#continue" id="continue"><h1>continue</h1></a>
<p>Continues execution with the next iteration of the inmost loop containing
the <code>continue</code> command.</p>
<a class="header" href="#example-5" id="example-5"><h2>Example</h2></a>
<pre><code class="language-Tcl">foreach item $list {
    ...
    if {[someCondition]} {
        continue
    }

    # Skips this code on [someCondition]
    ...
}
</code></pre>
<a class="header" href="#error-message" id="error-message"><h1>error <em>message</em></h1></a>
<p>Returns an error with the given <em>message</em>.  The error may
be caught using the <a href="ref/./catch.html"><strong>catch</strong></a> command.</p>
<a class="header" href="#example-6" id="example-6"><h2>Example</h2></a>
<pre><code class="language-tcl">proc myproc {x} {
    if {$x &lt; 0} {
        error &quot;input must be non-negative&quot;
    }
    ...
}
</code></pre>
<a class="header" href="#tcl-notes-2" id="tcl-notes-2"><h2>TCL Notes</h2></a>
<p>In standard TCL, the <code>error</code> command may also return a stack trace and an
error code.  In time Molt will likely implement the full error return protocol.</p>
<a class="header" href="#exit-returncode" id="exit-returncode"><h1>exit ?<em>returnCode</em>?</h1></a>
<p>Terminates the application by calling
<a href="https://doc.rust-lang.org/std/process/fn.exit.html"><code>std::process:exit()</code></a>
with the given <em>returnCode</em>, which must be an integer.  If not present,
the <em>returnCode</em> defaults to 0.</p>
<a class="header" href="#expr-expr" id="expr-expr"><h1>expr <em>expr</em></h1></a>
<p>Evaluates the expression, returning the result.</p>
<p><code>expr</code> implements a little language that has a syntax separate from that of Molt. An
expression is composed of values and operators, with parentheses for grouping, just
as in C, Java, and so forth.  Values consist of numeric and boolean literals,
<a href="#math-functions">function calls</a>, variable and command interpolations, and double-quoted
and braced strings. Every value that looks like a number is treated as a number, and every
value that looks like a <a href="#boolean-values">boolean</a> is treated as a boolean.</p>
<p>The <a href="#operators-and-precedence">operators</a> permitted in expressions include most of those
permitted in C expressions, with a few additional ones  The operators have the same
meaning and precedence as in C.  Expressions can yield numeric or non-numeric results.</p>
<p>Integer computations are done with Rust's <code>i64</code> type; floating-point computations are
done with Rust's <code>f64</code> type.</p>
<a class="header" href="#examples-2" id="examples-2"><h2>Examples</h2></a>
<pre><code class="language-tcl">expr {1 + 1}

set x 7.5
set y 3.4
expr {$x + $y}

expr {[mycommand] + 2}

expr {2*(1 + abs($x))}
</code></pre>
<a class="header" href="#operators-and-precedence" id="operators-and-precedence"><h2>Operators and Precedence</h2></a>
<p>The following table shows the operators in order of precedence.</p>
<table><thead><tr><th> Operators                 </th><th> Details                                          </th></tr></thead><tbody>
<tr><td> <code>- + ~ !</code>                 </td><td> Unary plus, minus, bit-wise not, and logical not </td></tr>
<tr><td> <code>* / %</code>                   </td><td> Multiplication, division, integer remainder      </td></tr>
<tr><td> <code>+ -</code>                     </td><td> Addition, subtraction                            </td></tr>
<tr><td> <code>&lt;&lt; &gt;&gt;</code>                   </td><td> Left and right shift.                            </td></tr>
<tr><td> <code>&lt; &gt; &lt;= &gt;=</code>               </td><td> Ordering relations (see below)                   </td></tr>
<tr><td> <code>== !=</code>                   </td><td> Equality, inequality (see below)                 </td></tr>
<tr><td> <code>eq ne</code>                   </td><td> String equality, inequality                      </td></tr>
<tr><td> <code>in ni</code>                   </td><td> List inclusion, exclusion                        </td></tr>
<tr><td> <code>&amp;</code>                       </td><td> Bit-wise AND                                     </td></tr>
<tr><td> <code>^</code>                       </td><td> Bit-wise exclusive OR                            </td></tr>
<tr><td> <code>|</code>       </td><td> Bit-wise OR                                      </td></tr>
<tr><td> <code>&amp;&amp;</code>                      </td><td> Logical AND, short circuiting                    </td></tr>
<tr><td> <code>||</code> </td><td> Logical OR, short circuiting                     </td></tr>
<tr><td> <code>x ? y : z</code>               </td><td> Ternary &quot;if-then-else&quot; operator.                 </td></tr>
</tbody></table>
<a class="header" href="#boolean-values" id="boolean-values"><h2>Boolean Values</h2></a>
<ul>
<li>True values: any non-zero number, <code>true</code>, <code>yes</code>, <code>on</code>.</li>
<li>False values: zero, <code>false</code>, <code>no</code>, <code>off</code>.</li>
<li>Logical operators always return 0 or 1.</li>
<li>By convention, predicate commands also return 0 or 1.</li>
</ul>
<a class="header" href="#math-functions" id="math-functions"><h2>Math Functions</h2></a>
<p>Functions are written as &quot;<em>name</em>(<em>argument</em>,...)&quot;.  Each argument is itself a complete
expression.</p>
<p>The following functions are available in Molt expressions:</p>
<p><strong>abs(<em>x</em>)</strong> — Absolute value of <em>x</em>.</p>
<p><strong>double(<em>x</em>)</strong> — Returns integer <em>x</em> as a floating-point value.</p>
<p><strong>int(<em>x</em>)</strong> — Truncates floating-point value <em>x</em> and returns it as an integer.</p>
<p><strong>round(<em>x</em>)</strong> — Rounds floating-point value <em>x</em> to the nearest integer and returns it as
an integer.</p>
<a class="header" href="#tcl-liens-1" id="tcl-liens-1"><h2>TCL Liens</h2></a>
<p><strong>Expr Command Syntax:</strong> In standard TCL <code>expr</code> takes any number of arguments, which it
concatenates into a single expression for evaluation.  This means that variable and command
interpolation is done twice, once by the TCL parser and once by <code>expr</code>, which hurts
performance and can also be a source of subtle and confusing errors.  Consequently it is
almost always best to provide the expression as a single braced string, and so Molt's <code>expr</code>
takes a single argument.  This is unlikely to change.</p>
<p><strong>Expression Syntax:</strong> Molt's expression parsing is meant to be consistent with TCL 7.6, with the
addition of the TCL 8.x <code>eq</code>, <code>ne</code>, <code>in</code>, and <code>ni</code> operators.</p>
<ul>
<li>Molt does not yet support the full range of math functions supported by TCL 7.6.</li>
<li>Molt does not yet do precise float-to-string-to-float conversions, per TCL 8.6.  See<br />
&quot;String Representation of Floating Point Numbers&quot; on the Tcler's Wiki expr page.</li>
<li>Molt's handling of floating point arithmetic errors is still naive.</li>
</ul>
<p><strong>Integer Division:</strong> Integer division in Molt rounds down towards zero, following the example
of Rust, Python, C99, and many other languages.  Standard TCL rounds toward negative
infinity, a decision that dates to a time when the C standard did not define the correct
behavior and C compilers varied.  It seems reasonable that an extension language should do
something as basic as this in the same way as the host language.</p>
<p><strong>Possible Futures:</strong> The following TCL 8.6 features are not on the road map at present,
but might be added in the future.</p>
<ul>
<li>Bignums</li>
<li>The exponential operator, <code>**</code></li>
<li>The <code>tcl::mathfunc::</code> namespace, and the ability to define new functions in TCL code.</li>
</ul>
<a class="header" href="#for-start-test-next-command" id="for-start-test-next-command"><h1>for <em>start</em> <em>test</em> <em>next</em> <em>command</em></h1></a>
<p>The <code>for</code> command provides a C-like &quot;for&quot; loop, where <em>start</em> is a script that initializes the
loop counter, <em>test</em> is a conditional expression, <em>next</em> is a script that updates the loop
counter, and <em>command</em> is the body script.</p>
<p>If the <em>command</em> script calls the <a href="ref/./break.html"><strong>break</strong></a> command, the loop terminates
immediately; if the <em>command</em> script calls the <a href="ref/./continue.html"><strong>continue</strong></a> command,
loop execution continues with the next iteration.</p>
<a class="header" href="#example-7" id="example-7"><h2>Example</h2></a>
<p>For example, the following loop counts from 0 to 9:</p>
<pre><code class="language-tcl">for {set i 0} {$i &lt; 10} {incr i} {
    puts &quot;i=$i&quot;
}
</code></pre>
<p>Note, though, that the <em>start</em> and <em>next</em> arguments are arbitrary scripts; for example, <em>start</em>
can initialize multiple variables, and <em>next</em> can update multiple variables.</p>
<a class="header" href="#foreach-varlist-list-body" id="foreach-varlist-list-body"><h1>foreach <em>varList</em> <em>list</em> <em>body</em></h1></a>
<p>Loops over the elements in the <em>list</em>, assigning them to the variables
in the <em>varList</em> and executing the <em>body</em> for each set of assignments.</p>
<p>The <a href="ref/./break.html">break</a> and <a href="ref/./continue.html">continue</a> commands can be
used to control loop execution; see their reference pages for details.</p>
<a class="header" href="#examples-3" id="examples-3"><h2>Examples</h2></a>
<p>Prints out the values &quot;1&quot;, &quot;2&quot;, and &quot;3&quot; on successive lines.</p>
<pre><code class="language-Tcl">foreach a {1 2 3} {
    puts $a
}
</code></pre>
<p>Prints out pairs of values from the list. In the final iteration there
is only value left, so <code>b</code> is assigned the empty string.</p>
<pre><code class="language-Tcl">foreach {a b} {1 2 3 4 5} {
    puts &quot;$a,$b&quot;
}
# Outputs:
#
#  1,2
#  3,4
#  5,
</code></pre>
<a class="header" href="#tcl-liens-2" id="tcl-liens-2"><h2>TCL Liens</h2></a>
<p>In standard TCL, <code>foreach</code> can iterate over multiple lists at the
same time, e.g., the following script will output the pairs &quot;a,1&quot;,
&quot;b,2&quot;, and &quot;c,3&quot;.  Molt doesn't currently support this extended syntax.</p>
<pre><code class="language-Tcl">foreach x {a b c} y {1 2 3} {
    puts &quot;$x,$y&quot;
}
</code></pre>
<a class="header" href="#global-varname-" id="global-varname-"><h1>global ?<em>varname</em> ...?</h1></a>
<p>Brings global variable(s) <em>varname</em> into scope in a
<a href="ref/./proc.html"><code>proc</code></a> body.  This command has no effect if called in the
global scope.</p>
<a class="header" href="#if-expr1-then-body1-elseif-expr2-then-body2-elseif--else-bodyn" id="if-expr1-then-body1-elseif-expr2-then-body2-elseif--else-bodyn"><h1>if <em>expr1</em> ?then? <em>body1</em> elseif <em>expr2</em> ?then? <em>body2</em> elseif ... ?else? ?<em>bodyN</em>?</h1></a>
<p>Tests a chain of one or more expressions, and executes the matching <em>body</em>,
which must be a script.  Returns the result of the last command executed in
the selected <em>body</em>.</p>
<p>Both the <code>then</code> and <code>else</code> keywords are optional.  The standard TCL
convention is to always omit the <code>then</code> keywords and to always
include the <code>else</code> keyword when there's an <code>else</code> clause.</p>
<a class="header" href="#examples-4" id="examples-4"><h2>Examples</h2></a>
<pre><code class="language-tcl">if {$x &gt; 0} {
    puts &quot;positive&quot;
}

if {$x &lt; 0} {
    puts &quot;negative&quot;
} else {
    puts &quot;non-negative&quot;
}

if {$x &gt; 0} {
    puts &quot;positive&quot;
} elseif {$x &lt; 0} {
    puts &quot;negative&quot;
} else {
    puts &quot;zero&quot;
}

set value [if {$x &gt; 0} {
    expr {$x + $y}   
} else {
    expr {$x - $y}   
}]
</code></pre>
<a class="header" href="#incr-varname-increment" id="incr-varname-increment"><h1>incr <em>varName</em> ?<em>increment</em>?</h1></a>
<p>Increments integer-valued-variable <em>varName</em> by the given <em>increment</em>, which defaults to 1.
If the variable is unset, it is set to the <em>increment</em>.  The command returns the incremented
value.</p>
<a class="header" href="#examples-5" id="examples-5"><h2>Examples</h2></a>
<pre><code class="language-tcl">unset a
incr a    ;# =&gt; 1
incr a    ;# =&gt; 2
incr a 3  ;# =&gt; 5

for {set a 1} {$a &lt; 10} {incr a} {
    ...
}
</code></pre>
<a class="header" href="#info-subcommand-arg-" id="info-subcommand-arg-"><h1>info <em>subcommand</em> ?<em>arg</em> ...?</h1></a>
<p>Returns information about the state of the Molt interpreter.</p>
<ul>
<li><a href="#info-commands">info commands</a></li>
<li><a href="#info-complete-command">info complete</a></li>
<li><a href="#info-vars">info vars</a></li>
</ul>
<a class="header" href="#info-commands" id="info-commands"><h2>info commands</h2></a>
<p>Returns an unsorted list of the commands defined in the interpreter,
including both binary commands and procs.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<a class="header" href="#info-complete-command" id="info-complete-command"><h2>info complete <em>command</em></h2></a>
<p>Returns 1 if the command appears to be a complete Tcl command, i.e., it
has no unmatched quotes, braces, or brackets, and 0 otherwise.  REPLs can
use this to allow the user to build up a multi-line command.</p>
<a class="header" href="#info-vars" id="info-vars"><h2>info vars</h2></a>
<p>Returns an unsorted list of the names of all variables that are visible
in the current scope, whether global or local.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<a class="header" href="#join-list-joinstring" id="join-list-joinstring"><h1>join <em>list</em> ?<em>joinString</em>?</h1></a>
<p>Joins the elements of a list into a string, including the <em>joinString</em>
in between each element.  If not given, the <em>joinString</em> defaults to
a single space character.</p>
<a class="header" href="#lindex-list-index-" id="lindex-list-index-"><h1>lindex <em>list</em> ?<em>index</em> ...?</h1></a>
<p>Returns an element from the <em>list</em>, indexing into nested lists.</p>
<a class="header" href="#list-arg-" id="list-arg-"><h1>list ?<em>arg</em> ...?</h1></a>
<p>Returns a list whose elements are the given arguments.  The list will
be in canonical list form.</p>
<a class="header" href="#llength-list" id="llength-list"><h1>llength <em>list</em></h1></a>
<p>Returns the length of the list.</p>
<a class="header" href="#proc-name-args-body" id="proc-name-args-body"><h1>proc <em>name</em> <em>args</em> <em>body</em></h1></a>
<p>Defines a procedure with the given <em>name</em>, argument list <em>args</em>, and
script <em>body</em>.  The procedure may be called like any built-in command.</p>
<p>The argument list, <em>args</em>, is a list of argument specifiers, each of
which may be:</p>
<ul>
<li>A name, representing a required argument</li>
<li>A list of two elements, a name and a default value, representing an
optional argument</li>
<li>The name <code>args</code>, representing any additional arguments.</li>
</ul>
<p>Optional arguments must follow required arguments, and <code>args</code> must
appear last.</p>
<p>When called, the procedure returns the result of the last command in the
body script, or the result of calling <a href="ref/./return.html"><code>return</code></a>, or an
error.</p>
<a class="header" href="#tcl-liens-3" id="tcl-liens-3"><h2>TCL Liens</h2></a>
<p>Molt does not support namespaces or namespace syntax in procedure names.</p>
<a class="header" href="#puts-string" id="puts-string"><h1>puts <em>string</em></h1></a>
<p>Outputs the <em>string</em> to standard output.</p>
<a class="header" href="#tcl-liens-4" id="tcl-liens-4"><h2>TCL Liens</h2></a>
<ul>
<li>Does not support <code>-nonewline</code></li>
<li>Does not support <code>?channelId?</code></li>
</ul>
<a class="header" href="#rename-oldname-newname" id="rename-oldname-newname"><h1>rename <em>oldName</em> <em>newName</em></h1></a>
<p>Renames the command called <em>oldName</em> to be <em>newName</em> instead.</p>
<p>Any command may be renamed in this way; it is a common TCL approach to wrap a command by
renaming it and defining a new command with the <em>oldName</em> that calls the old command at
its <em>newName</em>.</p>
<p>If the <em>newName</em> is the empty string, the command will be removed from the interpreter.</p>
<a class="header" href="#examples-6" id="examples-6"><h2>Examples</h2></a>
<pre><code class="language-tcl">proc myproc {} { ... }

# Rename the proc
rename myproc yourproc

# Remove the proc from the interpreter
rename yourproc &quot;&quot;
</code></pre>
<a class="header" href="#return-value" id="return-value"><h1>return ?<em>value</em>?</h1></a>
<p>Returns the given <em>value</em>, or the empty string if <em>value</em> is omitted.</p>
<a class="header" href="#tcl-liens-5" id="tcl-liens-5"><h2>TCL Liens</h2></a>
<ul>
<li>In TCL, <code>return</code> allows the caller to generate any valid TCL result code
(e.g., <code>break</code>) with complete and detailed control.  In Molt it only
provides the basic <code>return</code> semantics.</li>
</ul>
<a class="header" href="#set-varname-newvalue" id="set-varname-newvalue"><h1>set <em>varName</em> ?<em>newValue</em>?</h1></a>
<p>Sets variable <em>varName</em> to the <em>newValue</em>, returning the <em>newValue</em>.  If
<em>newValue</em> is omitted, simply returns the variable's existing value, or
returns an error if there is no existing value.</p>
<p>The <code>set</code> command operates in the current scope, e.g., in
<a href="ref/./proc.html"><code>proc</code></a> bodies it operates on the set of local variables.</p>
<p>See also: <a href="ref/./global.html"><code>global</code></a></p>
<a class="header" href="#tcl-liens-6" id="tcl-liens-6"><h2>TCL Liens</h2></a>
<ul>
<li>Molt does not support namespaces or namespace notation.</li>
</ul>
<a class="header" href="#time-command-count" id="time-command-count"><h1>time <em>command</em> ?<em>count</em>?</h1></a>
<p>Evaluates the given <em>command</em> the given number of times, or once if no count is specified,
timing each execution.  The average run time in microseconds is returned as a string,
&quot;<em>average</em> microseconds per iteration&quot;.</p>
<a class="header" href="#example-8" id="example-8"><h2>Example</h2></a>
<pre><code class="language-tcl">% time { mycommand } 1000
15 microseconds per iteration
%
</code></pre>
<a class="header" href="#unset-varname" id="unset-varname"><h1>unset <em>varName</em></h1></a>
<p>Unsets variable <em>varName</em>'s value.  The <code>unset</code> command has no effect if
no such variable is visible in the current scope.</p>
<a class="header" href="#tcl-differences" id="tcl-differences"><h2>TCL Differences</h2></a>
<p>In standard TCL, it's an error to unset a variable that doesn't exist; the
command provides the <code>-nocomplain</code> option to cover this case.  Per the TCL Core Team,
the <code>-nocomplain</code> option indicates, wherever it is found, that the original
definition of the command got it wrong.  In Molt, <code>unset</code> never complains.</p>
<a class="header" href="#while-test-command" id="while-test-command"><h1>while <em>test</em> <em>command</em></h1></a>
<p>The <code>while</code> command is a standard &quot;while&quot; loop, executing the <em>command</em> script just so
long as the <em>test</em> expression evaluates to true.</p>
<a class="header" href="#example-9" id="example-9"><h2>Example</h2></a>
<p>The following code will output the numbers from 1 to 10.</p>
<pre><code class="language-tcl">set i 0
while {$i &lt; 10} {
    puts &quot;i=[incr i]&quot;
}
</code></pre>
<a class="header" href="#embedding-molt" id="embedding-molt"><h1>Embedding Molt</h1></a>
<p>This chapter explains how to embed Molt in a Rust application.  There are several parts
to this:</p>
<ul>
<li>Creating a Molt interpreter</li>
<li><a href="embed/./commands.html">Defining application-specific Molt commands</a></li>
<li>Invoking the interpreter to <a href="embed/./eval.html">evaluate Molt commands and scripts</a></li>
</ul>
<p>An application may execute scripts for its own purposes and arbitrary scripts defined by
the user.  One common pattern is to define a <a href="embed/./shell.html">shell application</a> the user
may use to execute their own scripts using the application-specific command set.</p>
<p>It is also possible to define <a href="embed/./library.html">Molt library crate</a> that defines commands
for installation into an interpreter.</p>
<p>The initial step, creating a Molt interpreter, is trivially easy:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp;

let mut interp = Interp::new();

// Add application-specific commands
#}</code></pre></pre>
<p>This creates an interpreter containing the standard set of Molt commands.  Alternatively,
you can create a completely empty interpreter and add just the commands you want:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp;

let mut interp = Interp::empty();

// Add application-specific commands
#}</code></pre></pre>
<p>This is useful if you wish to use the Molt interpreter as a safe file parser.  Eventually there will be an API for adding specific standard Molt commands back into an empty
interpreter so that the application can create a custom command set (e.g., including
variable access and control structures but excluding file I/O), but that hasn't yet
been implemented.</p>
<p>We'll cover the remaining topics in the following sections.</p>
<a class="header" href="#the-molt-value-type" id="the-molt-value-type"><h1>The Molt <code>Value</code> Type</h1></a>
<p>The <code>Value</code> type is the standard representation in Rust of Molt values.  In the Tcl
language, &quot;everything is a string&quot;; which is to say, every value can be represented
as a string.  Many values—e.g., numbers and lists—also have a binary data representation,
but a single value can move from one binary data representation to another depending
on how it is used by the user.  Consider the following:</p>
<pre><code class="language-tcl">set x [expr {2 + 3}]  ;# It's the integer 5.
puts &quot;x=$x&quot;           ;# It's converted to a string.
set y [lindex $x 0]   ;# It's converted to a one-element list.
</code></pre>
<p>Initially, the variable <code>x</code> contains a <code>Value</code> with only a data representation, the
integer 5.  Then <code>puts</code> needs it as a string, and so the <code>Value</code> acquires a string
representation as well, but retains its integer representation.  Then <code>lindex</code> needs
to look at it as a list, so the string is parsed into a Molt list and the 0th element
is returned.  The integer representation is lost and replaced by the list
representation. The <code>Value</code> type manages all of these transformations internally, with the effect that string-to-binary and binary-to-string conversions happen only when
absolutely necessary.</p>
<p>Note: A <code>Value</code>'s string representation is never lost, once acquired: semantically,
<code>Values</code> are immutable.  The data transformations that go on under the hood are an
aid to performance, but in principle the value is unchanged.</p>
<a class="header" href="#creating-values" id="creating-values"><h2>Creating Values</h2></a>
<p><code>Values</code> can be created easily from a variety of kinds of input:</p>
<pre><code>let a = Value::from(&quot;abc&quot;);                              // &amp;str
let b = Value::from(&quot;def&quot;.to_string());                  // String
let c = Value::from(123);                                // MoltInt (i64)
let d = Value::from(45.67);                              // MoltFloat (f64)
let e = Value::from(true);                               // bool
let f = Value::from(&amp;[Value::from(1), Value::from(2)]);  // &amp;[Value]
</code></pre>
<p>And in fact, a <code>Value</code> can contain any Rust type that supports the <code>Display</code>,
<code>Debug</code>, and <code>FromStr</code> types via the <code>Value::from_other</code> method.  Such types are
called &quot;external types in the Molt documentation set.</p>
<a class="header" href="#cloning-values" id="cloning-values"><h2>Cloning Values</h2></a>
<p>Because <code>Values</code> are immutable, they have been designed to be cheaply and easy cloned
with reference counting via the standard <code>Rc</code> type.</p>
<a class="header" href="#retrieving-data-from-values" id="retrieving-data-from-values"><h2>Retrieving Data from Values</h2></a>
<p>It is always possible to retrieve a <code>Value</code>'s data as a string:</p>
<pre><code>let value = Value::from(5);
let text: String = value.to_string();
assert_eq!(&amp;text, &quot;5&quot;);
</code></pre>
<p>The <code>to_string</code> method creates a brand new <code>String</code> in the usual way; it is usually better to
use <code>as_str</code>, which returns an <code>&amp;str</code>:</p>
<pre><code>let value = Value::from(5);
let text = value.as_str();
assert_eq!(text, &quot;5&quot;);
</code></pre>
<p>It is also possible to retrieve data representations; but since this isn't guaranteed to
work the relevant methods all return <code>Result&lt;_,ResultCode&gt;</code>.  (See
<a href="embed/./molt_result.html">The <code>MoltResult</code> type</a> for a discussion of <code>ResultCodes</code>.)  For
example,</p>
<pre><code>let value = Value::from(&quot;123&quot;);
let x = value.as_int()?;
assert_eq!(x, 123);
</code></pre>
<a class="header" href="#retrieving-values-of-external-types" id="retrieving-values-of-external-types"><h2>Retrieving Values of External Types</h2></a>
<p>Values of external types can be retrieved as well using the <code>Value::as_copy</code> or
<code>Value::as_other</code> method, depending on whether the type implements the <code>Copy</code>
trait.  These are different than their peers, in that they return <code>Option&lt;T&gt;</code>
and <code>Option&lt;Rc&lt;T&gt;&gt;</code> rather than <code>Result&lt;T,ResultCode&gt;</code> or <code>Result&lt;Rc&lt;T&gt;,ResultCode&gt;</code>.
The reason is that Molt doesn't know what the appropriate
error message should be when it finds a value it can't convert into the external
type <code>T</code> and so returns <code>None</code>, leaving the error handling up to the client.</p>
<p>For this reason, when using an external type <code>MyType</code> with Molt it is usual to define a
function that converts a <code>Value</code> to a <code>Result&lt;MyType,ResultCode&gt;</code>.  If <code>MyType</code> is an
enum, for example, you might write this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl MyType {
    /// A convenience: retrieves the enumerated value, converting it from
    /// `Option&lt;MyType&gt;` into `Result&lt;MyType,ResultCode&gt;`.
    pub fn from_molt(value: &amp;Value) -&gt; Result&lt;Self, ResultCode&gt; {
        if let Some(x) = value.as_copy::&lt;MyType&gt;() {
            Ok(x)
        } else {
            Err(ResultCode::Error(Value::from(&quot;Not a MyType string&quot;)))
        }
    }
}
#}</code></pre></pre>
<a class="header" href="#the-moltresult-type" id="the-moltresult-type"><h1>The MoltResult Type</h1></a>
<p><code>MoltResult</code> is Molt's standard <code>Result&lt;T,E&gt;</code> type; it is defined as</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub type MoltResult = Result&lt;Value, ResultCode&gt;;
#}</code></pre></pre>
<p>The <code>Value</code> type is described in the <a href="embed/./molt_value.html">previous section</a>; by default, many
Molt methods and functions return <code>Value</code> on success.</p>
<p>The <code>ResultCode</code> is more complicated, as it is used to pass not only errors but also
to manage control flow.  It is defined as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Eq, PartialEq, Clone, Debug)]
pub enum ResultCode {
    Error(Value),
    Return(Value),
    Break,
    Continue,
}
#}</code></pre></pre>
<p>In addition to a normal <code>Ok</code> result, a Molt function, method, or command can return:</p>
<ul>
<li>
<p><code>ResultCode::Error(msg)</code>, where <code>msg</code> is an error message; this indicates that
something has thrown an error.</p>
</li>
<li>
<p><code>ResultCode::Return(value)</code>, which indicates that the Molt code has called the
<code>return</code> command; the <code>value</code> is the returned value.  Molt procedures, defined using
the <code>proc</code> command, will catch this and return <code>value</code> as the value of the procedure.</p>
</li>
<li>
<p><code>ResultCode::Break</code> and <code>ResultCode::Continue</code> are returned by the <code>break</code> and
<code>continue</code> commands and control loop execution in the usual way.</p>
</li>
</ul>
<a class="header" href="#molt_ok-and-molt_err" id="molt_ok-and-molt_err"><h2><code>molt_ok!</code> and <code>molt_err!</code></h2></a>
<p>Application-specific Rust code will usually only use <code>Ok(value)</code> and
<code>Err(ReturnCode::Error(value))</code>. Since these two cases pop up so often,
Molt provides a couple of macros to make them easier: <code>molt_ok!</code> and <code>molt_err!</code>.</p>
<p><code>molt_ok!</code> takes one or more arguments and converts them into an <code>Ok(Value)</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Returns the empty result.
return molt_ok!();

// Returns its argument as a Value (if Molt knows how to convert it)
return molt_ok!(5);

// A plain Value is OK to.
return molt_ok!(Value::from(5));

// Returns a formatted string as a Value using a Rust `format!` string.
return molt_ok!(&quot;The answer is {}.&quot;, x);
#}</code></pre></pre>
<p><code>molt_err!</code> works just the same way, but returns <code>Err(ReturnCode::Err(Value))</code>.</p>
<pre><code>if x &gt; 5 {
    return molt_err!(&quot;value is out of range: {}&quot;, x);
}
</code></pre>
<a class="header" href="#defining-commands" id="defining-commands"><h1>Defining Commands</h1></a>
<p>At base, a Molt command is a Rust function that performs some kind of work and optionally
returns a value in the context of a specific Rust interpreter.  There are four ways an
application (or library crate) can define application-specific Rust commands:</p>
<ul>
<li>As a simple Rust <code>CommandFunc</code> function</li>
<li>As a Rust <code>ContextCommandFunc</code> function that can access application-specific context</li>
<li>As a Rust <code>Command</code> object</li>
<li>As a Molt procedure, or <code>proc</code>.</li>
</ul>
<a class="header" href="#commandfunc-commands" id="commandfunc-commands"><h2><code>CommandFunc</code> Commands</h2></a>
<p>A <code>CommandFunc</code> command is any Rust function that implements <code>CommandFunc</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub type CommandFunc = fn(&amp;mut Interp, &amp;[Value]) -&gt; MoltResult;
#}</code></pre></pre>
<p>For example, here's a simple command that takes one argument and returns it
unchanged.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn cmd_ident(_interp: &amp;mut Interp, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 2, 2, &quot;value&quot;)?;

    molt_ok!(argv[1].clone())
}
#}</code></pre></pre>
<p>The <code>argv</code> vector contains the arguments to the command, beginning with the
command's name.  The <code>check_args</code> method verifies that the command has a write
number of arguments, and returns the standard Tcl error message if not.  Finally,
it uses <code>molt_ok!</code> to return its first argument.</p>
<p>Install this command into the interpreter using the <code>Interp::add_command</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
interp.add_command(&quot;ident&quot;, cmd_ident);
#}</code></pre></pre>
<a class="header" href="#contextcommandfunc-commands" id="contextcommandfunc-commands"><h2><code>ContextCommandFunc</code> Commands</h2></a>
<p>Normal <code>CommandFunc</code> commands are useful when extending the Molt language itself, but don't
help much when adding commands to manipulate the application and its data.  In this case,
it's often best to use a <code>ContextCommandFunc</code> in conjunction with the interpreter's
<em>context cache</em>.</p>
<p>The context cache is a hash map that allows the interpreter to keep arbitrary data and make
it available to commands. The usual pattern is like this:</p>
<ul>
<li>
<p>The application defines a type containing the data the command (or commands) requires.
We'll call it <code>AppContext</code> for the purpose of this example.</p>
</li>
<li>
<p>The application saves an instance of <code>AppContext</code> into the context cache, retrieving a
<code>ContextID</code>.</p>
</li>
<li>
<p>The application includes the <code>ContextID</code> when adding the command to the interpreter.</p>
</li>
<li>
<p>The command retrieves the <code>AppContext</code> as a mutable borrow.</p>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">// The AppContext
struct AppContext { text: String }

// The Command
fn cmd_whatsit(interp: &amp;mut Interp, context_id: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 2, 2, &quot;value&quot;)?;

    let ctx = interp.context::&lt;AppContext&gt;(context_id);

    // Save the first argument to the AppContext's text field.
    ctx.text.push_str(argv[1].as_str());

    molt_ok!()
}

// Registering the command
fn main() {
    let interp = Interp::new();
    let id = interp.save_context(AppContext::new());

    interp.add_context_command(&quot;whatsit&quot;, cmd_whatsit, id);

    ...
}
</code></pre></pre>
<a class="header" href="#command-objects" id="command-objects"><h2><code>Command</code> Objects</h2></a>
<p>Sometimes it's desirable to include more data as part of the command itself.  In this
case one can define a type that implements the <code>Command</code> trait, and register an instance
with the interp.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MyCommand {
    b: RefCell&lt;String&gt;,
}

impl Command for MyCommand {
    fn execute(&amp;self, interp: &amp;mut Interp, argv: &amp;[Value]) -&gt; MoltResult {
        ...
    }
}
#}</code></pre></pre>
<p>The instance is added to the interpreter using the <code>add_command_object</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
interp.add_command_object(&quot;my_command&quot;, MyCommand::new());
#}</code></pre></pre>
<p>This allows many additional patterns of use.  For example, objects in Tcl are often
represented as commands with associated data.  This can be handled using <code>Command</code> objects,
optionally in conjunction with the context cache:</p>
<ul>
<li>Command <code>myclass</code> creates a new instance, a Tcl command with its own context record
in the context cache.</li>
<li>The new instance can read and write from its instance data as needed.</li>
<li>The code of the &quot;class&quot; is defined by a struct that implements the <code>Command</code> trait.</li>
<li>The struct should also implement the <code>Drop</code> trait to release the context record
when the object goes away.</li>
</ul>
<p>TODO: We really need a bigger discussion of how to define Molt objects in Rust.</p>
<a class="header" href="#molt-procedures" id="molt-procedures"><h2>Molt Procedures</h2></a>
<p>A Molt procedure is a routine coded in Tcl and defined using the <code>proc</code> command. A
crate can compile Tcl procedures into itself using the <code>include_str!</code> macro.  Start
by defining a script that defines the required procedure, say, <code>procs.tcl</code>, and put it
in the crate's <code>src/</code> folder adjacent to the Rust file that will load it.  The Rust
file can then do this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut interp = Interp::new();

match interp.eval(include_str!(&quot;commands.tcl&quot;)) {
    Err(ResultCode::Error(msg)) =&gt; {
        panic!(&quot;Couldn't load procs.tcl: {}&quot;, msg);
    }
    _ =&gt; ()
}
#}</code></pre></pre>
<a class="header" href="#evaluating-molt-code" id="evaluating-molt-code"><h1>Evaluating Molt Code</h1></a>
<p>An application can evaluate Molt code in several ways:</p>
<ul>
<li>
<p>Use the <code>molt::Interp::eval</code> or <code>molt::Interp::eval_body</code> method to evaluate an
individual Molt command or script.</p>
</li>
<li>
<p>Use the <code>molt::expr</code> function to evaluate a Molt expression, returning a result.</p>
</li>
<li>
<p>Use the <code>molt::expr_test</code> method to evaluate a Molt boolean expression.</p>
</li>
<li>
<p>Use the <code>molt_shell::repl</code> function to provide an interactive REPL to the user.</p>
</li>
<li>
<p>Use the <code>molt_shell::script</code> function to evaluate a script file.</p>
</li>
</ul>
<a class="header" href="#evaluating-scripts-with-eval" id="evaluating-scripts-with-eval"><h2>Evaluating Scripts with <code>eval</code></h2></a>
<p>The <code>molt::Interp::eval</code> method evaluates a string as a Molt script and returns the result,
which will always be either <code>Ok(Value)</code> or <code>Err(ResultCode:Error(Value))</code>. (Other result
codes are translated into <code>Ok</code> or <code>Err</code> as appropriate.  See
<a href="embed/./molt_result.html">The <code>MoltResult</code> Type</a> for details.)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp;
use molt::types::*;

let mut interp = Interp::new();

...

let value: Value = interp.eval(&quot;...some Molt code...&quot;)?;
#}</code></pre></pre>
<p>The explicit <code>Value</code> type declaration is included for clarity.</p>
<a class="header" href="#evaluating-scripts-with-eval_body" id="evaluating-scripts-with-eval_body"><h2>Evaluating Scripts with <code>eval_body</code></h2></a>
<p>The <code>molt::Interp::eval_body</code> method is used when implementing control structures, as it
gives access to the entire set of <code>MoltResult</code> return codes.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp;
use molt::types::*;

fn my_cmd(interp: &amp;mut Interp, argv: &amp;[Value]) -&gt; MoltResult {
    // Get a Molt script to evaluate, e.g., a loop body:
    let body = argv[1];

    ...

    // Assume we're implementing some kind of loop.
    loop {
        ...

        // Evaluate the loop body
        let result = interp.eval_body(body.as_str());

        match result {
            Ok(value) =&gt; {
                // normal OK result.  What you do with it depends on the
                // control structure. There's probably nothing special to do
                // here; we'll just go on with the next iteration of the loop.
                continue;
            }
            Err(ResultCode::Err(msg)) =&gt; {
                // An error.  Control structures should usually let this
                // propagate.
                return result;
            }
            Err(ResultCode::Return(value)) =&gt; {
                // The code called the `return` command.  Let this propagate to
                // return from the enclosing `proc`.
                return result;
            }
            Err(ResultCode::Break) =&gt; {
                // The code called the `break` command.  If this function is
                // implementing a loop, it should return `Ok` to break out of
                // the loop; otherwise, let the `Break` propagate to break out
                // of the enclosing loop. Since this is a loop,  
                // break and return `Ok'
                break;
            }
            Err(ResultCode::Continue) =&gt; {
                // The code called the `continue` command.  If this function is
                // implementing a loop, this should continue on to the next
                // iteration of the loop after doing any necessary clean-up.  
                // Otherwise, let it propagate to continue in the enclosing loop.
                // Here, we're implementing a loop.
                continue;
            }
        }

        ...
    }

    ...
    // It's a loop, which normally returns an empty result.
    molt_ok!()
}
#}</code></pre></pre>
<p>See <a href="embed/./molt_result.html">The <code>MoltResult</code> Type</a> for more information.</p>
<p>The explicit <code>Value</code> type declaration is included for clarity.</p>
<a class="header" href="#evaluating-expressions-with-expr-and-bool_expr" id="evaluating-expressions-with-expr-and-bool_expr"><h2>Evaluating Expressions with <code>expr</code> and <code>bool_expr</code>.</h2></a>
<p>Evaluating Molt expressions is similar.  To get any expression result (usually a
numeric or boolean <code>Value</code>), use the <code>Interp::expr</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp;
use molt::types::*;
use molt::expr;

let mut interp = Interp::new();

...

let value: Value = interp.expr(&quot;1 + 1&quot;)?;
#}</code></pre></pre>
<p>Use <code>Interp::bool_expr</code> when a specifically boolean result is wanted:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let flag: bool = interp.bool_expr(&quot;1 == 1&quot;)?;
#}</code></pre></pre>
<p>(See the <a href="embed/../ref/expr.html"><code>expr</code></a> command reference for more about Molt expressions.)</p>
<a class="header" href="#providing-an-interactive-repl" id="providing-an-interactive-repl"><h2>Providing an interactive REPL</h2></a>
<p>An interactive user shell or &quot;REPL&quot; (Read-Eval-Print-Loop) can be a great convenience
when developing and debugging application scripts; it can also be useful tool for
administering server processes.  To provide an interactive, use
the <code>molt_shell::repl</code> function.</p>
<pre><code>use molt::Interp;

// FIRST, create and initialize the interpreter.
let mut interp = Interp::new();

// NOTE: commands can be added to the interpreter here.

// NEXT, invoke the REPL.
molt_shell::repl(&amp;mut interp, &quot;% &quot;);
</code></pre>
<a class="header" href="#evaluating-script-files" id="evaluating-script-files"><h2>Evaluating Script Files</h2></a>
<p>To execute a user script file, one can load the file contents and use <code>Interp::eval</code> in
the normal way, or use the <code>molt_shell::script</code> function.  A shell application might
execute a user script as follows.  Any errors are output to the console.</p>
<pre><code>use molt::Interp;
use std::env;

// FIRST, get the command line arguments.
let args: Vec&lt;String&gt; = env::args().collect();

// NEXT, create and initialize the interpreter.
let mut interp = Interp::new();

// NOTE: commands can be added to the interpreter here.

// NEXT, evaluate the file, if any.
if args.len() &gt; 1 {
    molt_shell::script(&amp;mut interp, &amp;args[1..]);
} else {
    eprintln!(&quot;Usage: myshell *filename.tcl&quot;);
}
</code></pre>
<a class="header" href="#custom-shells" id="custom-shells"><h1>Custom Shells</h1></a>
<a class="header" href="#molt-library-crates" id="molt-library-crates"><h1>Molt Library Crates</h1></a>
<p>A Molt library crate is simply a Rust crate that can install commands into a
Molt interpreter using any of the methods described in this chapter.<br />
For example, a crate might provide an <code>install</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp

pub fn install(interp: &amp;mut Interp) {
    interp.add_command(&quot;mycommand&quot;, mycommand);
    ...
}
#}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
