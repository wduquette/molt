<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Molt Book</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="overview.html"><strong aria-hidden="true">1.</strong> Molt: More Or Less Tcl</a></li><li><ol class="section"><li><a href="tcl_comp.html"><strong aria-hidden="true">1.1.</strong> Tcl Compatibility</a></li></ol></li><li><a href="cmdline/cmdline.html"><strong aria-hidden="true">2.</strong> Molt Command Line Tool</a></li><li><ol class="section"><li><a href="cmdline/molt_shell.html"><strong aria-hidden="true">2.1.</strong> molt shell</a></li><li><a href="cmdline/molt_test.html"><strong aria-hidden="true">2.2.</strong> molt test</a></li><li><ol class="section"><li><a href="cmdline/test_commands/test.html"><strong aria-hidden="true">2.2.1.</strong> test</a></li></ol></li><li><a href="cmdline/molt_bench.html"><strong aria-hidden="true">2.3.</strong> molt bench</a></li><li><ol class="section"><li><a href="cmdline/bench_commands/benchmark.html"><strong aria-hidden="true">2.3.1.</strong> benchmark</a></li><li><a href="cmdline/bench_commands/measure.html"><strong aria-hidden="true">2.3.2.</strong> measure</a></li><li><a href="cmdline/bench_commands/ok.html"><strong aria-hidden="true">2.3.3.</strong> ok</a></li><li><a href="cmdline/bench_commands/ident.html"><strong aria-hidden="true">2.3.4.</strong> ident</a></li></ol></li></ol></li><li><a href="ref/reference.html"><strong aria-hidden="true">3.</strong> Molt Command Reference</a></li><li><ol class="section"><li><a href="ref/append.html"><strong aria-hidden="true">3.1.</strong> append</a></li><li><a href="ref/array.html"><strong aria-hidden="true">3.2.</strong> array</a></li><li><a href="ref/assert_eq.html"><strong aria-hidden="true">3.3.</strong> assert_eq</a></li><li><a href="ref/break.html"><strong aria-hidden="true">3.4.</strong> break</a></li><li><a href="ref/catch.html"><strong aria-hidden="true">3.5.</strong> catch</a></li><li><a href="ref/continue.html"><strong aria-hidden="true">3.6.</strong> continue</a></li><li><a href="ref/dict.html"><strong aria-hidden="true">3.7.</strong> dict</a></li><li><a href="ref/error.html"><strong aria-hidden="true">3.8.</strong> error</a></li><li><a href="ref/exit.html"><strong aria-hidden="true">3.9.</strong> exit</a></li><li><a href="ref/expr.html"><strong aria-hidden="true">3.10.</strong> expr</a></li><li><a href="ref/for.html"><strong aria-hidden="true">3.11.</strong> for</a></li><li><a href="ref/foreach.html"><strong aria-hidden="true">3.12.</strong> foreach</a></li><li><a href="ref/global.html"><strong aria-hidden="true">3.13.</strong> global</a></li><li><a href="ref/if.html"><strong aria-hidden="true">3.14.</strong> if</a></li><li><a href="ref/incr.html"><strong aria-hidden="true">3.15.</strong> incr</a></li><li><a href="ref/info.html"><strong aria-hidden="true">3.16.</strong> info</a></li><li><a href="ref/join.html"><strong aria-hidden="true">3.17.</strong> join</a></li><li><a href="ref/lindex.html"><strong aria-hidden="true">3.18.</strong> lindex</a></li><li><a href="ref/list.html"><strong aria-hidden="true">3.19.</strong> list</a></li><li><a href="ref/llength.html"><strong aria-hidden="true">3.20.</strong> llength</a></li><li><a href="ref/proc.html"><strong aria-hidden="true">3.21.</strong> proc</a></li><li><a href="ref/puts.html"><strong aria-hidden="true">3.22.</strong> puts</a></li><li><a href="ref/rename.html"><strong aria-hidden="true">3.23.</strong> rename</a></li><li><a href="ref/return.html"><strong aria-hidden="true">3.24.</strong> return</a></li><li><a href="ref/set.html"><strong aria-hidden="true">3.25.</strong> set</a></li><li><a href="ref/time.html"><strong aria-hidden="true">3.26.</strong> time</a></li><li><a href="ref/unset.html"><strong aria-hidden="true">3.27.</strong> unset</a></li><li><a href="ref/while.html"><strong aria-hidden="true">3.28.</strong> while</a></li></ol></li><li><a href="embed/overview.html"><strong aria-hidden="true">4.</strong> Extending and Embedding</a></li><li><ol class="section"><li><a href="embed/molt_value.html"><strong aria-hidden="true">4.1.</strong> The Molt Value Type</a></li><li><a href="embed/molt_result.html"><strong aria-hidden="true">4.2.</strong> The MoltResult Type</a></li><li><a href="embed/commands.html"><strong aria-hidden="true">4.3.</strong> Defining Commands</a></li><li><a href="embed/eval.html"><strong aria-hidden="true">4.4.</strong> Evaluating Molt Code</a></li><li><a href="embed/shell.html"><strong aria-hidden="true">4.5.</strong> Custom Shell Applications</a></li><li><a href="embed/library.html"><strong aria-hidden="true">4.6.</strong> Molt Library Crates</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Molt Book</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#molt-more-or-less-tcl" id="molt-more-or-less-tcl"><h1>Molt: More Or Less Tcl</h1></a>
<p><strong>Molt 0.2.0</strong> is a minimal implementation of the TCL language for embedding in Rust apps
and for scripting Rust libraries.  Molt is intended to be:</p>
<ul>
<li>
<p><strong>Small in size.</strong> Embedding Molt shouldn't greatly increase the size of the
application.</p>
</li>
<li>
<p><strong>Small in language.</strong> <a href="http://tcl-lang.org">Standard TCL</a> has many features
intended for building entire software systems.  Molt is intentionally
limited to those needed for embedding.</p>
</li>
<li>
<p><strong>Small in dependencies.</strong> Including the Molt interpreter in your project shouldn't
drag in anything else--unless you ask for it.</p>
</li>
<li>
<p><strong>Easy to build.</strong> Building Standard TCL is non-trivial.  Embedding
Molt should be as simple as using any other crate.</p>
</li>
<li>
<p><strong>Easy to embed.</strong> Extending Molt with TCL commands that wrap Rust APIs should
be easy and simple.</p>
</li>
</ul>
<p>Hence, perfect compatibility with Standard TCL is explicitly not a goal.  Many
features will not be implemented at all (e.g., octal literals); and others may
be implemented somewhat differently where a clearly better alternative exists
(e.g., <code>-nocomplain</code> will always be the normal behavior).  In addition, Molt will
prefer Rust standards where appropriate.</p>
<p>On the other hand, Molt is meant to be TCL (more or less), not simply a
&quot;Tcl-like language&quot;, so gratuitous differences are to be avoided.  One of the
goals of this document is to carefully delineate:</p>
<ul>
<li>The features that have not yet been implemented.</li>
<li>The features that likely will never be implemented.</li>
<li>Any small differences in behavior.</li>
<li>And especially, any features that have intentionally been implemented in
a different way.</li>
</ul>
<a class="header" href="#what-molt-is-for" id="what-molt-is-for"><h2>What Molt Is For</h2></a>
<p>Using Molt, you can:</p>
<ul>
<li>Create a shell interpreter for scripting and interactive testing of your Rust crates.</li>
<li>Provide your Rust applications with an interactive REPL for debugging and
administration.</li>
<li>Extend your Rust application with scripts provided at compile-time or at run-time.</li>
<li>Allow your users to script your applications and libraries.</li>
</ul>
<p>See the <a href="https://github.com/wduquette/molt-sample"><code>molt-sample</code> repo</a> for a sample Molt client
skeleton.</p>
<a class="header" href="#new-in-molt-022" id="new-in-molt-022"><h2>New in Molt 0.2.2</h2></a>
<a class="header" href="#dictionaries-and-the-dict-command" id="dictionaries-and-the-dict-command"><h3>Dictionaries and the <code>dict</code> command</h3></a>
<p>Molt now supports TCL dictionary values.  The <a href="ref/dict.html"><code>dict</code></a> command provides the
following subcommands:</p>
<ul>
<li>dict create</li>
<li>dict exists</li>
<li>dict keys</li>
<li>dict get</li>
<li>dict remove</li>
<li>dict set</li>
<li>dict size</li>
<li>dict unset</li>
<li>dict values</li>
</ul>
<p>Other <code>dict</code> subcommands will be added over time.</p>
<a class="header" href="#new-in-molt-02" id="new-in-molt-02"><h2>New in Molt 0.2</h2></a>
<a class="header" href="#associative-arrays" id="associative-arrays"><h3>Associative Arrays</h3></a>
<p>Molt now includes TCL's associative array variables:</p>
<pre><code class="language-text">% set a(1) &quot;Howdy&quot;
Howdy
% set a(foo.bar) 5
5
% puts [array get a]
1 Howdy foo.bar 5
</code></pre>
<a class="header" href="#the-expansion-operator" id="the-expansion-operator"><h3>The Expansion Operator</h3></a>
<p>Molt now supports TCL's <code>{*}</code> operator, which expands a single
command argument into multiple arguments:</p>
<pre><code class="language-text">% set a {a b c}
a b c
% list 1 2 $a 3 4
1 2 {a b c} 3 4
% list 1 2 {*}$a 3 4
1 2 a b c 3 4
</code></pre>
<a class="header" href="#more-info-subcommands" id="more-info-subcommands"><h3>More <code>info</code> Subcommands</h3></a>
<p>Molt now supports the following subcommands of the <a href="ref/info.html"><code>info</code></a> command:</p>
<ul>
<li><code>info args</code></li>
<li><code>info body</code></li>
<li><code>info cmdtype</code></li>
<li><code>info default</code></li>
<li><code>info exists</code></li>
<li><code>info globals</code> (no glob-filtering as yet)</li>
<li><code>info locals</code> (no glob-filtering as yet)</li>
<li><code>info procs</code></li>
</ul>
<a class="header" href="#rust-api-change-test-harness" id="rust-api-change-test-harness"><h3>Rust API Change: Test Harness</h3></a>
<p>The Molt test harness code has moved from <code>molt_shell:test_harness</code> to <code>molt::test_harness</code>,
so that it can be used in the <code>molt/tests/tcl_tests.rs</code> integration test.</p>
<a class="header" href="#rust-api-change-variable-access" id="rust-api-change-variable-access"><h3>Rust API Change: Variable Access</h3></a>
<p>The addition of array variables required changes to the <code>molt::Interp</code> struct's API for
setting and retrieving variables.  In particular, the <code>molt::Interp::var</code>,
<code>molt::Interp::set_var</code>, and <code>molt::Interp::set_and_return</code> methods now take the variable
name as a <code>&amp;Value</code> rather than a <code>&amp;str</code>; this simplifies client code, and means that most
commands implemented in Rust that work with variables don't need to care whether the
variable in question is a scalar or an array element.</p>
<a class="header" href="#rust-api-change-command-definition" id="rust-api-change-command-definition"><h3>Rust API Change: Command Definition</h3></a>
<p>Defining Molt commands in Rust has been simplified.</p>
<p>First, the <code>Command</code> trait has been removed.  It was intended to provide a way to
attach context data to a command; but it was not very good for mutable data, and had
no way to share data among related commands (a common pattern).</p>
<p>Second, the interpreter's context cache has been improved.  Multiple commands can share a
context ID (and hence access to the shared context); and the cached data will be dropped
automatically when the last such command is removed from the interpreter.</p>
<p>Third, there is now only one command function signature:</p>
<pre><code>fn my_command(interp: &amp;mut Interp, context_id: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    ...
}
</code></pre>
<p>Commands that don't use a cached context should be defined as follows:</p>
<pre><code>fn my_command(interp: &amp;mut Interp, _: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    ...
}
</code></pre>
<a class="header" href="#coming-attractions" id="coming-attractions"><h2>Coming Attractions</h2></a>
<p>At this point Molt is capable and robust enough for real work, though the Rust-level API is
not yet completely stable.  Standard Rust <code>0.y.z</code> semantic versioning applies: &quot;.y&quot; changes
can break the Rust-level API, &quot;.z&quot; changes will not.</p>
<ul>
<li>Feature: Regex and Glob pattern matching by Molt commands</li>
<li>Testing improvements</li>
<li>Documentation improvements</li>
</ul>
<a class="header" href="#tcl-compatibility" id="tcl-compatibility"><h1>Tcl Compatibility</h1></a>
<p>Molt is aiming at limited compatibility with TCL 8.x, the current stable version
of Standard TCL, as described <a href="overview.html">above</a>.  The development plan is as follows:</p>
<ul>
<li>Implement the complete Molt semantics
<ul>
<li>Core interpreter</li>
<li>Essential TCL commands</li>
<li>Robust and ergonomic Rust-level API for extending TCL in Rust</li>
<li>Related tools (e.g., TCL-level test harness)</li>
<li>Thorough and complete test suite (at both Rust and TCL levels)</li>
<li>Thorough documentation</li>
</ul>
</li>
<li>Optimize for speed
<ul>
<li>Ideally including byte-compilation</li>
</ul>
</li>
<li>Extend with new features as requested.</li>
</ul>
<p>Each TCL command provided standard by the Molt interpreter is documented in this
book with a complete <a href="./ref/reference.html">man page</a>.  A command's man page documents
the semantics of the command, and any temporary or permanent differences between it and the
similarly named command in <a href="http://tcl-lang.org">Standard TCL</a>.</p>
<p>The remainder of this section documents overall differences; see the
<a href="https://github.com/wduquette/molt">Molt README</a> for details on current
development.</p>
<p>Note that some of the features described as never to be implemented
could conceivably be added as extension crates.</p>
<a class="header" href="#features-that-already-exist" id="features-that-already-exist"><h2>Features that already exist</h2></a>
<p>See the <a href="./ref/reference.html">command reference</a> for the set of commands that
have already been implemented.  The current set of features includes:</p>
<p>At the TCL Level:</p>
<ul>
<li>Script execution</li>
<li>Procedure definition</li>
<li>Standard control structures (except the <code>switch</code> command)</li>
<li>Local and global variables, including associate arrays</li>
<li>Boolean and numeric expressions</li>
<li>Many standard TCL commands</li>
<li>A modicum of introspection</li>
</ul>
<p>At the Rust Level:</p>
<ul>
<li>A clean and modular embedding API</li>
<li>The <code>Interp</code> struct (e.g., Standard TCL's Interp)
<ul>
<li>API for defining new commands in Rust, setting and querying variables, and
evaluating TCL code.</li>
</ul>
</li>
<li>The <code>Value</code> type (e.g., Tcl_Obj)
<ul>
<li>TCL values are strings; <code>Value</code> shares them efficiently by reference counting, and
caches binary data representations for run-time efficiency.</li>
</ul>
</li>
</ul>
<p>Related Tools:</p>
<ul>
<li>An interactive REPL
<ul>
<li>Using the <code>rustyline</code> crate for line editing.</li>
</ul>
</li>
<li>A shell, for execution of script files</li>
<li>A test harness</li>
</ul>
<a class="header" href="#features-to-be-added-soon" id="features-to-be-added-soon"><h2>Features to be added soon</h2></a>
<p>See the <a href="overview.html">overview</a> and the Molt README.</p>
<a class="header" href="#features-to-be-added-eventually" id="features-to-be-added-eventually"><h2>Features to be added eventually</h2></a>
<ul>
<li>Globs and Regexes</li>
<li>Some way to create ensembles commands and simple objects</li>
<li>Dictionaries</li>
<li>Byte Compilation</li>
</ul>
<a class="header" href="#features-that-might-someday-be-added-depending-on-demand" id="features-that-might-someday-be-added-depending-on-demand"><h2>Features that might someday be added (depending on demand)</h2></a>
<ul>
<li>Namespaces</li>
<li>Slave interpreters</li>
<li>File I/O</li>
<li>Event loop</li>
<li>Communication between <code>Interps</code> in different threads</li>
<li>Traces</li>
<li>Some kind of TCL-level module architecture</li>
</ul>
<a class="header" href="#features-that-will-almost-certainly-never-be-added" id="features-that-will-almost-certainly-never-be-added"><h2>Features that will almost certainly never be added</h2></a>
<ul>
<li>The TCL autoloader</li>
<li>Packages/TCL Modules (as represented in Standard TCL)</li>
<li>Coroutines</li>
<li>Support for dynamically loading Molt extensions written in Rust</li>
<li>Support for Molt extensions written in C (or anything but Rust)
<ul>
<li>But note that a Molt extension written in Rust can certainly call into
C libraries in the usual way.</li>
</ul>
</li>
<li>Network I/O</li>
<li>OOP (in the form of TclOO)</li>
</ul>
<a class="header" href="#miscellaneous-differences" id="miscellaneous-differences"><h2>Miscellaneous Differences</h2></a>
<p>See the man pages for specific commands for other differences.</p>
<ul>
<li>Integer literals beginning with &quot;0&quot; are NOT assumed to be octal,
Nor will they ever be.</li>
<li>The encoding is currently always UTF-8.</li>
<li>In variable names, e.g. <code>$name</code>, the name may include underscores and any character that
Rust considers to be alphanumeric.</li>
<li>The notion of what constitutes whitespace is generally left up to Rust.</li>
<li>When using the TCL shell interactively, TCL will attempt to match
partial names of commands and subcommands as a convenience.  Molt does not.
<ul>
<li>In principle, some form of tab-completion could be added at some point.</li>
</ul>
</li>
</ul>
<a class="header" href="#molt-command-line-tool" id="molt-command-line-tool"><h1>Molt Command Line Tool</h1></a>
<p>The <code>molt-app</code> crate provides a command line tool for use in development and
experimentation. The command line tool, called <code>molt</code>, has several subcommands:</p>
<p><a href="cmdline/./molt_shell.html"><strong>molt shell</strong></a> executes scripts and provides an
interactive REPL.</p>
<p><a href="cmdline/./molt_test.html"><strong>molt test</strong></a> executes Molt test suites, most notably
Molt's own test suite.</p>
<p><a href="cmdline/./molt_bench.html"><strong>molt bench</strong></a> executes Molt benchmarks.  This tool is
experimental, and is primarily for use in optimizing molt itself.</p>
<p>Note: the <code>molt-shell</code> crate provides the same features for use with customized Molt interpreters.</p>
<a class="header" href="#molt-shell-script-args" id="molt-shell-script-args"><h1>molt shell ?<em>script</em>? ?<em>args...</em>?</h1></a>
<p>The <code>molt shell</code> command invokes the Molt interpreter.</p>
<a class="header" href="#interactive-use" id="interactive-use"><h2>Interactive Use</h2></a>
<p>When called without any arguments, the command invokes the interactive interpreter:</p>
<pre><code class="language-tcl">$ molt shell
Molt 0.2.0
%
</code></pre>
<p>Molt commands may be entered at the <code>%</code> prompt.  Enter <code>exit</code> to leave the interpreter.</p>
<a class="header" href="#script-execution" id="script-execution"><h2>Script Execution</h2></a>
<p>When called with arguments, the first argument is presumed to be the name of a Molt script;
any subsequent arguments are passed to the script.</p>
<pre><code class="language-tcl">$ molt shell my_script.tcl arg1 arg2 arg3
...
$
</code></pre>
<p>When called in this way, the variable <strong>arg0</strong> contains the name of the script, and the
variable <strong>argv</strong> contains a list of the additional arguments (if any).</p>
<p>For example, consider the following script, <code>args.tcl</code>:</p>
<pre><code class="language-tcl">puts &quot;arg0 = $arg0&quot;
puts &quot;argv = $argv&quot;
</code></pre>
<p>This script may be run as follows</p>
<pre><code class="language-tcl">$ molt shell args.tcl a b c
arg0 = args.tcl
argv = a b c
$

## TCL Liens

The Standard TCL shell, `tclsh`, provides a number of features that Molt currently does not.

*   A `.tclshrc` file for initializing interactive shells.
    *   This can be added if there is demand; however, Molt is not primarily intended
        for general purpose scripting.

*   An option to execute a script and then start the interactive shell.
    *   This can be added if there is demand.

*   Environment variables for locating the interpreter's library of TCL code, locally
    installed TCL packages, etc.
    *   Molt's library of TCL code is compiled into the interpreter, rather than being
        loaded from disk at run-time.
    *   At present, Molt has no support for externally-defined TCL packages
        (other than the `source` command).
</code></pre>
<a class="header" href="#molt-test-filename-args" id="molt-test-filename-args"><h1>molt test <em>filename</em> ?<em>args...</em>?</h1></a>
<p>This command executes the test script called <em>filename</em> using the Molt
test harness, which is similar to Standard TCL's <code>tcltest</code> framework (though
much simpler, at present). Any arguments are passed to the test harness
(which ignores them, at present).</p>
<a class="header" href="#test-suites" id="test-suites"><h2>Test Suites</h2></a>
<p><code>molt test</code> is often used to execute an entire test suite, spread over
multiple files.  To simplify writing such a suite, <code>molt test</code> assumes
that the folder containing the specified <em>filename</em> is the base folder for
the test suite, and sets the current working directory to that folder.
This allows the named test script to use <a href="cmdline/../ref/source.html"><strong>source</strong></a> to
load other test scripts using paths relative to its own location.</p>
<a class="header" href="#writing-tests" id="writing-tests"><h2>Writing Tests</h2></a>
<p>Tests are written using the <a href="cmdline/../ref/test.html"><strong>test</strong></a> command.  See
that man page for examples.</p>
<a class="header" href="#running-tests" id="running-tests"><h2>Running Tests</h2></a>
<p>For example,</p>
<pre><code class="language-tcl">$ molt test good_tests.tcl
molt 0.2.0 -- Test Harness

5 tests, 5 passed, 0 failed, 0 errors
$ molt test bad_tests.tcl
molt 0.2.0 -- Test Harness

*** FAILED mytest-1.1 some proc
Expected -ok &lt;this result&gt;
Received -ok &lt;that result&gt;

2 tests, 1 passed, 1 failed, 0 errors
</code></pre>
<a class="header" href="#test-name-description-args-" id="test-name-description-args-"><h1>test <em>name</em> <em>description</em> <em>args ...</em></h1></a>
<p><strong>Available in <a href="cmdline/test_commands/../molt_test.html"><strong>molt test</strong></a> scripts only!</strong></p>
<p>The <code>test</code> command executes its body as a Molt script and compares its result
to an expected value.  It may be used to test Molt commands, whether built-in or coded
in Molt.  The expected value may be an <code>-ok</code> result or an <code>-error</code> message.</p>
<p>The <em>name</em> and <em>description</em> are used to identify the test in the output.  The
<em>name</em> can be any string, but the convention is to use the format
&quot;<em>baseName</em>-<em>x</em>.<em>y</em>&quot;, e.g., <code>mycommand-1.1</code>.  In the future, <code>molt test</code>
will allow the user to filter the set of tests on this name string.</p>
<p>The test is executed in its own local variable scope; variables used by the
test will be cleaned up automatically at the end of the test.  The
<a href="cmdline/test_commands/../../ref/global.html"><strong>global</strong></a> command may be used to reference global variables; however,
changes to these must be cleaned up explicitly.  Similarly, any
<a href="cmdline/test_commands/../../ref/proc.html"><strong>procs</strong></a> defined by the test must be cleaned up explicitly.</p>
<p>The <code>test</code> command has two forms, a brief form and an extended form with more options.</p>
<a class="header" href="#test-name-description-body--ok-error-expectedvalue" id="test-name-description-body--ok-error-expectedvalue"><h2>test <em>name</em> <em>description</em> <em>body</em> -ok|-error <em>expectedValue</em></h2></a>
<p>In the brief form, the <em>body</em> is the test script itself; and it is expected to return
a normal result or an error message.  Either way, <em>expectedValue</em> is the expected value.</p>
<ul>
<li>The test <strong>passes</strong> if the <em>body</em> returns the right kind of result with the expected value.</li>
<li>The test <strong>fails</strong> if the <em>body</em> returns the right kind of result (e.g., <code>-ok</code>) with
some other value.</li>
<li>The test is in <strong>error</strong> if the <em>body</em> returns the wrong kind of result, (e.g., an
error was returned when a normal result was expected).</li>
</ul>
<a class="header" href="#test-name-description-option-value-option-value-" id="test-name-description-option-value-option-value-"><h2>test <em>name</em> <em>description</em> <em>option value</em> ?<em>option value ...</em>?</h2></a>
<p>In the extended form, the details of the test are specified using options:</p>
<ul>
<li>
<p><strong>-setup</strong>: indicates a setup script, which will be executed before the body of the
test.  The test is flagged as an <strong>error</strong> if the setup script returns anything
but a normal result.</p>
</li>
<li>
<p><strong>-body</strong>: indicates the test's <em>body</em>, which is interpreted as described above.</p>
</li>
<li>
<p><strong>-cleanup</strong>: indicates a cleanup script, which will be executed after the body of the
test.  The test is flagged as an <strong>error</strong> if the cleanup script returns anything but
a normal result.</p>
</li>
<li>
<p><strong>-ok | -error</strong>: indicates the expected value, as described above.</p>
</li>
</ul>
<a class="header" href="#examples" id="examples"><h2>Examples</h2></a>
<p>The following tests are for an imaginary <code>square</code> command that returns the square
of a number.  They use the brief form.</p>
<pre><code class="language-Tcl">test square-1.1 {square errors} {
    square
} -error {wrong # args: should be &quot;square number&quot;}

test square-2.1 {square command} {
    square 3
} -ok {9}
</code></pre>
<p>The following test shows the extended form:</p>
<pre><code class="language-Tcl">test newproc-1.1 {new proc} -setup {
    # Define a proc for use in the test
    proc myproc {} { return &quot;called myproc&quot; }
} -body {
    # Call the proc
    myproc
} -cleanup {
    # Clean up the proc
    rename myproc &quot;&quot;
} -error {called myproc}
</code></pre>
<a class="header" href="#tcl-notes" id="tcl-notes"><h2>TCL Notes</h2></a>
<p>This command is a simplified version of the <code>test</code> command defined by
Standard TCL's <code>tcltest(n)</code> framework.  The intention is to increase the
similarity over time.</p>
<p>This command has an enhancement over TCL's <code>test</code> command: the test has
its own local variable scope, just as a <a href="cmdline/test_commands/../../ref/proc.html"><strong>proc</strong></a> does.  The body
must use the <a href="cmdline/test_commands/../../ref/global.html"><strong>global</strong></a> command to access global variables.</p>
<a class="header" href="#molt-bench-filename--csv" id="molt-bench-filename--csv"><h1>molt bench <em>filename</em> ?-csv?</h1></a>
<p>This command executes the benchmark script called <em>filename</em> using the Molt benchmark
framework. The framework runs the benchmarks in the script and outputs the results in
nanoseconds.</p>
<p><strong>NOTE:</strong> The benchmark tool is experimental, subject to change, and primarily intended
as aid for Molt optimization.</p>
<p>The output looks like this.</p>
<pre><code class="language-console">$ molt bench benchmarks/basic.tcl
Molt 0.2.0 -- Benchmark

   Nanos     Norm -- Benchmark
    3344     1.00 -- ok-1.1 ok, no arguments
    4110     1.23 -- ok-1.2 ok, one argument
    4442     1.33 -- ok-1.3 ok, two arguments
    4005     1.20 -- ident-1.1 ident, simple argument
    7175     2.15 -- incr-1.1 incr a
    6648     1.99 -- set-1.1 set var value
    7926     2.37 -- list-1.1 list of six items
...
$
</code></pre>
<p>The <code>Norm</code> column shows the times relative to the first benchmark in the set.</p>
<a class="header" href="#csv-output" id="csv-output"><h2>CSV Output</h2></a>
<p>Use the <code>-csv</code> option to produce output in CSV format:</p>
<pre><code class="language-console">$ molt bench benchmarks/basic.tcl -csv
&quot;benchmark&quot;,&quot;description&quot;,&quot;nanos&quot;,&quot;norm&quot;
&quot;ok-1.1&quot;,&quot;ok, no arguments&quot;,3313,1
&quot;ok-1.2&quot;,&quot;ok, one argument&quot;,4027,1.2155146392997283
&quot;ok-1.3&quot;,&quot;ok, two arguments&quot;,4439,1.3398732266827649
&quot;ident-1.1&quot;,&quot;ident, simple argument&quot;,4026,1.2152127980682161
&quot;incr-1.1&quot;,&quot;incr a&quot;,7325,2.210987020827045
&quot;set-1.1&quot;,&quot;set var value&quot;,6499,1.9616661635979475
&quot;list-1.1&quot;,&quot;list of six items&quot;,7848,2.3688499849079383
...
</code></pre>
<a class="header" href="#writing-benchmarks" id="writing-benchmarks"><h2>Writing Benchmarks</h2></a>
<p>Benchmarks are written using the <a href="cmdline/./bench_commands/benchmark.html"><strong>benchmark</strong></a> or
<a href="cmdline/./bench_commands/measure.html"><strong>measure</strong></a> commands.  See those man pages for examples.</p>
<a class="header" href="#benchmark-name-description-body-count" id="benchmark-name-description-body-count"><h1>benchmark <em>name</em> <em>description</em> <em>body</em> ?<em>count</em>?</h1></a>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>Defines a benchmark with the given name and description.  The <em>body</em> is a Tcl script; it is executed <em>count</em> times via the <a href="cmdline/bench_commands/../../ref/time.html"><strong>time</strong></a> command, and records the average runtime in microseconds.  The count defaults to 1000 iterations.</p>
<p>The <em>name</em> should be a symbolic name for easy searching; the <em>description</em> should be a
brief human-readable description of the benchmark.</p>
<a class="header" href="#example" id="example"><h2>Example</h2></a>
<p>The following is a simple benchmark of the <a href="cmdline/bench_commands/../../ref/incr.html"><strong>incr</strong></a> command.</p>
<pre><code class="language-tcl">benchmark incr-1.1 {incr a} {
    incr a
}
</code></pre>
<a class="header" href="#measure-name-description-micros" id="measure-name-description-micros"><h1>measure <em>name</em> <em>description</em> <em>micros</em></h1></a>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>This is a low-level command used by the <a href="cmdline/bench_commands/./benchmark.html"><strong>benchmark</strong></a> command
to record measurements.  All recorded measurements will be included in the tool's
output.</p>
<p>Benchmark scripts won't usually need to call this; however, it can
be useful when defining custom benchmarking commands.</p>
<a class="header" href="#example-1" id="example-1"><h2>Example</h2></a>
<pre><code class="language-tcl">measure incr-1.1 &quot;incr a&quot; 1.46
</code></pre>
<a class="header" href="#ok-arg-arg" id="ok-arg-arg"><h1>ok ?<em>arg</em> <em>arg</em>...?</h1></a>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>This command takes any number of arguments and returns the empty string.  It is useful when benchmarking code that calls other commands, as (with no arguments) it represents the minimum
amount of computation the Molt interpreter can do.</p>
<a class="header" href="#example-2" id="example-2"><h2>Example</h2></a>
<p>For example, Molt's own benchmark suite includes the following as its baseline, as a lower bound on the run-time of evaluating a script:</p>
<pre><code class="language-tcl">benchmark ok-1.1 {ok, no arguments} {
    ok
}
</code></pre>
<a class="header" href="#ident-value" id="ident-value"><h1>ident <em>value</em></h1></a>
<p><strong>Available in <a href="cmdline/bench_commands/../molt_bench.html"><strong>molt bench</strong></a> scripts only!</strong></p>
<p>Returns its argument unchanged.  Like <a href="cmdline/bench_commands/./ok.html"><strong>ok</strong></a>, this is a command used for
constructing benchmarks of the Molt interpreter itself.</p>
<a class="header" href="#molt-command-reference" id="molt-command-reference"><h1>Molt Command Reference</h1></a>
<p>Molt implements the following commands.  See the reference for each
command to see any differences from Standard TCL.</p>
<a class="header" href="#append-varname-value-" id="append-varname-value-"><h1>append <em>varName</em> ?<em>value</em> ...?</h1></a>
<p>Appends zero or more values to the value of variable <em>varName</em>.
If <em>varName</em> didn't previously exist, it is set to the concatenation
of the values.</p>
<a class="header" href="#examples-1" id="examples-1"><h2>Examples</h2></a>
<pre><code class="language-Tcl">set x &quot;this&quot;
append x &quot;that&quot;
assert_eq $x &quot;thisthat&quot;

append y a b c
assert_eq $y abc
</code></pre>
<a class="header" href="#array-subcommand-arg-" id="array-subcommand-arg-"><h1>array <em>subcommand</em> ?<em>arg</em> ...?</h1></a>
<p>This command queries and manipulates array variables.</p>
<table><thead><tr><th> Subcommand                    </th><th> Description                                  </th></tr></thead><tbody>
<tr><td> <a href="#array-exists">array exists</a> </td><td> Is the string the name of an array variable? </td></tr>
<tr><td> <a href="#array-get">array get</a>       </td><td> A dictionary of the array's elements by name </td></tr>
<tr><td> <a href="#array-names">array names</a>   </td><td> A list of the array's indices                </td></tr>
<tr><td> <a href="#array-size">array size</a>     </td><td> The number of elements in the array          </td></tr>
<tr><td> <a href="#array-unset">array unset</a>   </td><td> Unsets an array variable                     </td></tr>
</tbody></table>
<p><strong>TCL Liens</strong></p>
<ul>
<li>Does not support filtering using glob or regex matches at this time.  The plan is to
support glob and regex matching as a configuration option at build time.</li>
<li>Will never support the array iteration commands <code>array startsearch</code>, <code>array anymore</code>,
<code>array donesearch</code>, <code>array nextelement</code>, because they are unnecessary and rarely used.
The normal idiom for iterating over an array is a <code>foreach</code> over <code>array names</code>.</li>
<li>Will never support <code>array statistics</code>, as Rust's <code>std::collections::HashMap</code> doesn't
provide a way to gather them.</li>
</ul>
<a class="header" href="#array-exists-arrayname" id="array-exists-arrayname"><h2>array exists <em>arrayName</em></h2></a>
<p>Returns 1 if <em>arrayName</em> names an array variable, and 0 otherwise.</p>
<a class="header" href="#array-get-arrayname" id="array-get-arrayname"><h2>array get <em>arrayName</em></h2></a>
<p>Returns a flat list of the keys and values in the named array.  The key/value pairs appear
in unsorted order. If there is no array variable with the given name, returns the empty list.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using glob and regex matches.</p>
<a class="header" href="#array-names-arrayname" id="array-names-arrayname"><h2>array names <em>arrayName</em></h2></a>
<p>Returns an unsorted list of the indices of the named array variable.  If there is no array
variable with the given name, returns the empty list.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using glob and regex matches.</p>
<a class="header" href="#array-set-arrayname-list" id="array-set-arrayname-list"><h2>array set <em>arrayName</em> <em>list</em></h2></a>
<p>Merges a flat list of keys and values into the array, creating the array variable if necessary.
The list must have an even number of elements.  It's an error if the variable exists but has
a scalar value, or if <em>arrayName</em> names an array element.</p>
<a class="header" href="#array-size-arrayname" id="array-size-arrayname"><h2>array size <em>arrayName</em></h2></a>
<p>Returns the number of elements in the named array.  If there is no array
variable with the given name, returns &quot;0&quot;.</p>
<a class="header" href="#array-unset-arrayname-index" id="array-unset-arrayname-index"><h2>array unset <em>arrayName</em> ?<em>index</em>?</h2></a>
<p>Unsets the array element in <em>arrayName</em> with the given <em>index</em>.  If index is not given,
unsets the entire array.</p>
<p>Note:</p>
<ul>
<li><code>array unset my_array</code> is equivalent to <code>unset my_array</code>, but only works on array variables.</li>
<li><code>array unset my_array my_index</code> is equivalent to <code>unset my_array(my_index)</code></li>
</ul>
<p>The real value of <code>array unset</code> depends on pattern matching on the index argument, which is
not yet available.</p>
<p><strong>TCL Liens</strong>: does not support glob matching on the optional argument.</p>
<a class="header" href="#assert_eq-received-expected" id="assert_eq-received-expected"><h1>assert_eq <em>received</em> <em>expected</em></h1></a>
<p>Asserts that the string <em>received</em> equals the string <em>expected</em>.  On success,
returns the empty string; on failure, returns an error.</p>
<p>This command is primarily intended for use in examples, to show the expected
result of a computation, rather than for use in test suites.  For testing,
see the <a href="ref/./test.html"><code>test</code></a> command and the
<a href="ref/../cmdline/molt_test.html"><code>molt test</code></a> tool.</p>
<a class="header" href="#tcl-notes-1" id="tcl-notes-1"><h2>TCL Notes</h2></a>
<p>This command is not part of Standard TCL; it is provided because of its
similarity to the Rust <code>assert_eq!</code> macro.</p>
<a class="header" href="#break" id="break"><h1>break</h1></a>
<p>Breaks execution of the inmost loop containing the <code>break</code> command,
continuing execution after the loop.</p>
<a class="header" href="#example-3" id="example-3"><h2>Example</h2></a>
<pre><code class="language-Tcl">foreach item $list {
    ...
    if {[someCondition]} {
        break
    }
    ...
}

# Execution continues here after the break
</code></pre>
<a class="header" href="#catch-script-resultvarname-optionsvarname" id="catch-script-resultvarname-optionsvarname"><h1>catch <em>script</em> ?<em>resultVarName</em>? ?<em>optionsVarName</em>?</h1></a>
<p>Executes the script, catching the result, including any errors.  The return value of <code>catch</code>
is an integer code that indicates why the script returned.  If <em>resultVarName</em> is given, the
named variable is set to the actual return value in the caller's scope.  If <em>optionsVarName</em> is
given, the named variable is set to the <a href="ref/./return.html"><strong>return</strong></a> options dictionary.</p>
<p>There are five return codes:</p>
<table><thead><tr><th> Return Code  </th><th> Effect </th></tr></thead><tbody>
<tr><td> 0 (normal)   </td><td> Normal. The result variable is set to the script's result. </td></tr>
<tr><td> 1 (error)    </td><td> A command in the script threw an error. The result variable is set to the error message. </td></tr>
<tr><td> 2 (return)   </td><td> The script called <a href="ref/./return.html"><strong>return</strong></a>. The result variable is set to the returned value. </td></tr>
<tr><td> 3 (break)    </td><td> The script called <a href="ref/./break.html"><strong>break</strong></a>. </td></tr>
<tr><td> 4 (continue) </td><td> The script called <a href="ref/./continue.html"><strong>continue</strong></a>. </td></tr>
</tbody></table>
<a class="header" href="#example-4" id="example-4"><h2>Example</h2></a>
<p><code>catch</code> is most often used to catch errors.  For example,</p>
<pre><code class="language-tcl">if {[catch {do_something} result]} {
    puts &quot;Error result: $result&quot;
} else {
    puts &quot;Good result: $result&quot;
}
</code></pre>
<p>The <a href="ref/./return.html"><strong>return</strong></a> options can be used to rethrow the error:</p>
<pre><code class="language-tcl">if {[catch {do_something} errMsg opts]} {
    puts &quot;Error result: $errMsg&quot;
    return -options $opts $errMsg
} else {
    puts &quot;Good result: $result&quot;
}
</code></pre>
<a class="header" href="#continue" id="continue"><h1>continue</h1></a>
<p>Continues execution with the next iteration of the inmost loop containing
the <code>continue</code> command.</p>
<a class="header" href="#example-5" id="example-5"><h2>Example</h2></a>
<pre><code class="language-Tcl">foreach item $list {
    ...
    if {[someCondition]} {
        continue
    }

    # Skips this code on [someCondition]
    ...
}
</code></pre>
<a class="header" href="#dict-subcommand-arg-" id="dict-subcommand-arg-"><h1>dict <em>subcommand</em> ?<em>arg</em> ...?</h1></a>
<p>This command manipulates TCL dictionaries.  A dictionary is a Molt value containing a hash map
from keys to values.  Keys are maintained in order of initial insertion.</p>
<table><thead><tr><th> Subcommand                                       </th><th> Description                                  </th></tr></thead><tbody>
<tr><td> <a href="#dict-create-key-value-">dict create</a>           </td><td> Creates a dictionary                         </td></tr>
<tr><td> <a href="#dict-exists-dictionary-key-key-">dict exists</a>  </td><td> Is there a value with these keys?            </td></tr>
<tr><td> <a href="#dict-get-dictionary-key-">dict get</a>            </td><td> Gets a value from the dictionary             </td></tr>
<tr><td> <a href="#dict-keys-dictionary">dict keys</a>               </td><td> Gets the keys from the dictionary            </td></tr>
<tr><td> <a href="#dict-remove-dictionary-key-">dict remove</a>      </td><td> Removes keys from the dictionary             </td></tr>
<tr><td> <a href="#dict-set-dictvarname-key-key--value">dict set</a> </td><td> Sets a value in a dictionary                 </td></tr>
<tr><td> <a href="#dict-unset-dictvarname-key-">dict unset</a>       </td><td> Unsets a value in a dictionary                </td></tr>
<tr><td> <a href="#dict-size-dictionary">dict size</a>               </td><td> The number of elements in the dictionary     </td></tr>
<tr><td> <a href="#dict-values-dictionary">dict values</a>           </td><td> Gets the values from the dictionary          </td></tr>
</tbody></table>
<p><strong>TCL Liens</strong></p>
<ul>
<li>Not all of the standard TCL <code>dict</code> subcommands are implemented at this time.</li>
<li><code>dict keys</code> and <code>dict values</code> do not support filtering using glob or regex matches
at this time.  The plan is to support glob and regex matching as an optional feature.</li>
<li><code>dict info</code> is not supported; it is intended for tuning the standard TCL hash table
implementation.  Molt relies on <code>std::collections::HashMap</code>.</li>
</ul>
<a class="header" href="#dict-create-key-value-" id="dict-create-key-value-"><h2>dict create ?<em>key</em> <em>value</em> ...?</h2></a>
<p>Creates a dictionary given any number of key/value pairs.</p>
<pre><code class="language-tcl">% set dict [dict create a 1 b 2]
a 1 b 2
% dict get $dict a
1
</code></pre>
<a class="header" href="#dict-exists-dictionary-key-key-" id="dict-exists-dictionary-key-key-"><h2>dict exists <em>dictionary</em> <em>key</em> ?<em>key</em> ...?</h2></a>
<p>Returns 1 if the <em>key</em> (or the path of keys through nested dictionaries) is found in the
given <em>dictionary</em> value, and 0 otherwise.  It returns 1 exactly when <code>dict get</code> will
succeed for the same arguments.  It does not throw errors on invalid dictionary values, but
simply returns 0.</p>
<p>Looks up the <em>key</em> in the <em>dictionary</em> and returns its value.  It's an error if the <em>key</em> is
not present in the dictionary.  If multiple keys are provided, the command looks up values
through nested dictionaries.  If no keys are provided, the dictionary itself is returned.</p>
<pre><code class="language-tcl">% dict exists {a 1 b 2} b
1
% dict exists {a {x 1 y2} b {p 3 q 4}} b p
1
% dict exists {a 1 b 2} c
0
% dict exists not-a-dict a
0
</code></pre>
<a class="header" href="#dict-get-dictionary-key-" id="dict-get-dictionary-key-"><h2>dict get <em>dictionary</em> ?<em>key</em> ...?</h2></a>
<p>Looks up the <em>key</em> in the <em>dictionary</em> and returns its value.  It's an error if the <em>key</em> is
not present in the dictionary.  If multiple keys are provided, the command looks up values
through nested dictionaries.  If no keys are provided, the dictionary itself is returned.</p>
<pre><code class="language-tcl">% dict get {a 1 b 2} b
2
% dict get {a {x 1 y2} b {p 3 q 4}} b p
3
</code></pre>
<a class="header" href="#dict-keys-dictionary" id="dict-keys-dictionary"><h2>dict keys <em>dictionary</em></h2></a>
<p>Returns a list of the keys in the dictionary, in the order of initial insertion.</p>
<pre><code class="language-tcl">% dict keys {a 1 b 2}
a b
</code></pre>
<a class="header" href="#dict-remove-dictionary-key-" id="dict-remove-dictionary-key-"><h2>dict remove <em>dictionary</em> ?<em>key</em> ...?</h2></a>
<p>Removes each of the keys from the dictionary, returning the modified dictionary.  The keys
need not be present in the original dictionary value.  If no keys are given, returns the
dictionary unchanged.</p>
<pre><code class="language-tcl">% dict remove {a 1 b 2 c 3 d 4} b c
a 1 d 4
</code></pre>
<a class="header" href="#dict-set-dictvarname-key-key--value" id="dict-set-dictvarname-key-key--value"><h2>dict set <em>dictVarName</em> <em>key</em> ?<em>key</em> ...? <em>value</em></h2></a>
<p>Given the name of a variable containing a dictionary, sets the <em>value</em> of the given <em>key</em> in
the dictionary. If multiple keys are given, the command indexes down the path of keys and sets
the value in the nested dictionary.  The variable is created if it does not exist, and the nested
dictionaries are also created as needed.  Returns the modified dictionary, which is also saved
back into the variable.</p>
<p>For example,</p>
<pre><code class="language-tcl">% dict set var a 1
a 1
% dict set var b 2
a 1 b 2
% dict set var c x 3
a 1 b 2 c {x 3}
% dict set var c y z 4
a 1 b 2 c {x 3 y {z 4}}
</code></pre>
<a class="header" href="#dict-size-dictionary" id="dict-size-dictionary"><h2>dict size <em>dictionary</em></h2></a>
<p>Gets the number of entries in the <em>dictionary</em>.</p>
<pre><code>% set dict [dict create a 1 b 2 c 3]
a 1 b 2 c 3
% dict size $dict
3
</code></pre>
<a class="header" href="#dict-unset-dictvarname-key-" id="dict-unset-dictvarname-key-"><h2>dict unset <em>dictVarName</em> ?<em>key</em> ...?</h2></a>
<p>Given the name of a variable containing a dictionary, removes the <em>value</em> at the end of the path
of keys through any number of nested dictionaries.  The last key need not exist in the inmost
dictionary, but it is an error if any of the other dictionaries in the path are unknown.
Returns the modified dictionary, which is also saved back into the variable.</p>
<p>For example,</p>
<pre><code class="language-tcl">% set var {a 1 b {x 2 z 3} c 4}
a 1 b {x 2 y 3} c 4
% dict unset c        ;# Remove &quot;c&quot; from the outermost dictionary
a 1 b {x 2 y 3}
% dict unset b y      ;# Remove &quot;y&quot; from an inner dictionary &quot;b&quot;
a 1 b {x 2}
% dict unset var c    ;# &quot;c&quot; is already not there
a 1 b {x 2}
% dict unset var b y  ;# &quot;y&quot; is already not in &quot;b&quot;
a 1 b {x 2}
% dict unset var c z  ;# Inner dictionary &quot;c&quot; is not present.
key &quot;c&quot; is not known in dictionary
</code></pre>
<a class="header" href="#dict-values-dictionary" id="dict-values-dictionary"><h2>dict values <em>dictionary</em></h2></a>
<p>Returns a list of the values in the dictionary, in the order of initial insertion of
their keys.</p>
<pre><code class="language-tcl">% dict values {a 1 b 2}
1 2
</code></pre>
<a class="header" href="#error-message" id="error-message"><h1>error <em>message</em></h1></a>
<p>Returns an error with the given <em>message</em> and an error code of <code>NONE</code>.  The error may
be caught using the <a href="ref/./catch.html"><strong>catch</strong></a> command.</p>
<a class="header" href="#example-6" id="example-6"><h2>Example</h2></a>
<pre><code class="language-tcl">proc myproc {x} {
    if {$x &lt; 0} {
        error &quot;input must be non-negative&quot;
    }
    ...
}
</code></pre>
<a class="header" href="#tcl-liens" id="tcl-liens"><h2>TCL Liens</h2></a>
<p>In standard TCL, the <code>error</code> also has optional <code>errorInfo</code> and <code>errorCode</code> arguments.  These
are used in older TCL code to rethrow errors without polluting the stack trace.  Modern TCL code
uses the <a href="ref/./throw.html"><strong>throw</strong></a> command to throw an error with an error code and the
<a href="ref/./return.html"><strong>return</strong></a> command to rethrow an error (see the reference page for an
example).  Consequently, Molt doesn't implement these arguments.</p>
<a class="header" href="#exit-returncode" id="exit-returncode"><h1>exit ?<em>returnCode</em>?</h1></a>
<p>Terminates the application by calling
<a href="https://doc.rust-lang.org/std/process/fn.exit.html"><code>std::process:exit()</code></a>
with the given <em>returnCode</em>, which must be an integer.  If not present,
the <em>returnCode</em> defaults to 0.</p>
<a class="header" href="#expr-expr" id="expr-expr"><h1>expr <em>expr</em></h1></a>
<p>Evaluates the expression, returning the result.</p>
<p><code>expr</code> implements a little language that has a syntax separate from that of Molt. An
expression is composed of values and operators, with parentheses for grouping, just
as in C, Java, and so forth.  Values consist of numeric and boolean literals,
<a href="#math-functions">function calls</a>, variable and command interpolations, and double-quoted
and braced strings. Every value that looks like a number is treated as a number, and every
value that looks like a <a href="#boolean-values">boolean</a> is treated as a boolean.</p>
<p>The <a href="#operators-and-precedence">operators</a> permitted in expressions include most of those
permitted in C expressions, with a few additional ones  The operators have the same
meaning and precedence as in C.  Expressions can yield numeric or non-numeric results.</p>
<p>Integer computations are done with Rust's <code>i64</code> type; floating-point computations are
done with Rust's <code>f64</code> type.</p>
<a class="header" href="#examples-2" id="examples-2"><h2>Examples</h2></a>
<pre><code class="language-tcl">expr {1 + 1}

set x 7.5
set y 3.4
expr {$x + $y}

expr {[mycommand] + 2}

expr {2*(1 + abs($x))}
</code></pre>
<a class="header" href="#operators-and-precedence" id="operators-and-precedence"><h2>Operators and Precedence</h2></a>
<p>The following table shows the operators in order of precedence.</p>
<table><thead><tr><th> Operators                 </th><th> Details                                          </th></tr></thead><tbody>
<tr><td> <code>- + ~ !</code>                 </td><td> Unary plus, minus, bit-wise not, and logical not </td></tr>
<tr><td> <code>* / %</code>                   </td><td> Multiplication, division, integer remainder      </td></tr>
<tr><td> <code>+ -</code>                     </td><td> Addition, subtraction                            </td></tr>
<tr><td> <code>&lt;&lt; &gt;&gt;</code>                   </td><td> Left and right shift.                            </td></tr>
<tr><td> <code>&lt; &gt; &lt;= &gt;=</code>               </td><td> Ordering relations (see below)                   </td></tr>
<tr><td> <code>== !=</code>                   </td><td> Equality, inequality (see below)                 </td></tr>
<tr><td> <code>eq ne</code>                   </td><td> String equality, inequality                      </td></tr>
<tr><td> <code>in ni</code>                   </td><td> List inclusion, exclusion                        </td></tr>
<tr><td> <code>&amp;</code>                       </td><td> Bit-wise AND                                     </td></tr>
<tr><td> <code>^</code>                       </td><td> Bit-wise exclusive OR                            </td></tr>
<tr><td> <code>|</code>       </td><td> Bit-wise OR                                      </td></tr>
<tr><td> <code>&amp;&amp;</code>                      </td><td> Logical AND, short circuiting                    </td></tr>
<tr><td> <code>||</code> </td><td> Logical OR, short circuiting                     </td></tr>
<tr><td> <code>x ? y : z</code>               </td><td> Ternary &quot;if-then-else&quot; operator.                 </td></tr>
</tbody></table>
<a class="header" href="#boolean-values" id="boolean-values"><h2>Boolean Values</h2></a>
<ul>
<li>True values: any non-zero number, <code>true</code>, <code>yes</code>, <code>on</code>.</li>
<li>False values: zero, <code>false</code>, <code>no</code>, <code>off</code>.</li>
<li>Logical operators always return 0 or 1.</li>
<li>By convention, predicate commands also return 0 or 1.</li>
</ul>
<a class="header" href="#math-functions" id="math-functions"><h2>Math Functions</h2></a>
<p>Functions are written as &quot;<em>name</em>(<em>argument</em>,...)&quot;.  Each argument is itself a complete
expression.</p>
<p>The following functions are available in Molt expressions:</p>
<p><strong>abs(<em>x</em>)</strong>  Absolute value of <em>x</em>.</p>
<p><strong>double(<em>x</em>)</strong>  Returns integer <em>x</em> as a floating-point value.</p>
<p><strong>int(<em>x</em>)</strong>  Truncates floating-point value <em>x</em> and returns it as an integer.</p>
<p><strong>round(<em>x</em>)</strong>  Rounds floating-point value <em>x</em> to the nearest integer and returns it as
an integer.</p>
<a class="header" href="#tcl-liens-1" id="tcl-liens-1"><h2>TCL Liens</h2></a>
<p><strong>Expr Command Syntax:</strong> In standard TCL <code>expr</code> takes any number of arguments, which it
concatenates into a single expression for evaluation.  This means that variable and command
interpolation is done twice, once by the TCL parser and once by <code>expr</code>, which hurts
performance and can also be a source of subtle and confusing errors.  Consequently it is
almost always best to provide the expression as a single braced string, and so Molt's <code>expr</code>
takes a single argument.  This is unlikely to change.</p>
<p><strong>Expression Syntax:</strong> Molt's expression parsing is meant to be consistent with TCL 7.6, with the
addition of the TCL 8.x <code>eq</code>, <code>ne</code>, <code>in</code>, and <code>ni</code> operators.</p>
<ul>
<li>Molt does not yet support the full range of math functions supported by TCL 7.6.</li>
<li>Molt does not yet do precise float-to-string-to-float conversions, per TCL 8.6.  See<br />
&quot;String Representation of Floating Point Numbers&quot; on the Tcler's Wiki expr page.</li>
<li>Molt's handling of floating point arithmetic errors is still naive.</li>
</ul>
<p><strong>Integer Division:</strong> Integer division in Molt rounds down towards zero, following the example
of Rust, Python, C99, and many other languages.  Standard TCL rounds toward negative
infinity, a decision that dates to a time when the C standard did not define the correct
behavior and C compilers varied.  It seems reasonable that an extension language should do
something as basic as this in the same way as the host language.</p>
<p><strong>Possible Futures:</strong> The following TCL 8.6 features are not on the road map at present,
but might be added in the future.</p>
<ul>
<li>Bignums</li>
<li>The exponential operator, <code>**</code></li>
<li>The <code>tcl::mathfunc::</code> namespace, and the ability to define new functions in TCL code.</li>
</ul>
<a class="header" href="#for-start-test-next-command" id="for-start-test-next-command"><h1>for <em>start</em> <em>test</em> <em>next</em> <em>command</em></h1></a>
<p>The <code>for</code> command provides a C-like &quot;for&quot; loop, where <em>start</em> is a script that initializes the
loop counter, <em>test</em> is a conditional expression, <em>next</em> is a script that updates the loop
counter, and <em>command</em> is the body script.</p>
<p>If the <em>command</em> script calls the <a href="ref/./break.html"><strong>break</strong></a> command, the loop terminates
immediately; if the <em>command</em> script calls the <a href="ref/./continue.html"><strong>continue</strong></a> command,
loop execution continues with the next iteration.</p>
<a class="header" href="#example-7" id="example-7"><h2>Example</h2></a>
<p>For example, the following loop counts from 0 to 9:</p>
<pre><code class="language-tcl">for {set i 0} {$i &lt; 10} {incr i} {
    puts &quot;i=$i&quot;
}
</code></pre>
<p>Note, though, that the <em>start</em> and <em>next</em> arguments are arbitrary scripts; for example, <em>start</em>
can initialize multiple variables, and <em>next</em> can update multiple variables.</p>
<a class="header" href="#foreach-varlist-list-body" id="foreach-varlist-list-body"><h1>foreach <em>varList</em> <em>list</em> <em>body</em></h1></a>
<p>Loops over the elements in the <em>list</em>, assigning them to the variables
in the <em>varList</em> and executing the <em>body</em> for each set of assignments.</p>
<p>The <a href="ref/./break.html">break</a> and <a href="ref/./continue.html">continue</a> commands can be
used to control loop execution; see their reference pages for details.</p>
<a class="header" href="#examples-3" id="examples-3"><h2>Examples</h2></a>
<p>Prints out the values &quot;1&quot;, &quot;2&quot;, and &quot;3&quot; on successive lines.</p>
<pre><code class="language-Tcl">foreach a {1 2 3} {
    puts $a
}
</code></pre>
<p>Prints out pairs of values from the list. In the final iteration there
is only value left, so <code>b</code> is assigned the empty string.</p>
<pre><code class="language-Tcl">foreach {a b} {1 2 3 4 5} {
    puts &quot;$a,$b&quot;
}
# Outputs:
#
#  1,2
#  3,4
#  5,
</code></pre>
<a class="header" href="#tcl-liens-2" id="tcl-liens-2"><h2>TCL Liens</h2></a>
<p>In standard TCL, <code>foreach</code> can iterate over multiple lists at the
same time, e.g., the following script will output the pairs &quot;a,1&quot;,
&quot;b,2&quot;, and &quot;c,3&quot;.  Molt doesn't currently support this extended syntax.</p>
<pre><code class="language-Tcl">foreach x {a b c} y {1 2 3} {
    puts &quot;$x,$y&quot;
}
</code></pre>
<a class="header" href="#global-varname-" id="global-varname-"><h1>global ?<em>varname</em> ...?</h1></a>
<p>Brings global variable(s) <em>varname</em> into scope in a
<a href="ref/./proc.html"><code>proc</code></a> body.  This command has no effect if called in the
global scope.</p>
<a class="header" href="#tcl-differences" id="tcl-differences"><h2>TCL Differences</h2></a>
<p>At the script level, <code>global</code> works the same in Molt as in Standard
TCL.  However, Molt's internal implementation of variables is currently much
simpler than standard TCL's, e.g., no arrays, no namespaces.</p>
<a class="header" href="#if-expr1-then-body1-elseif-expr2-then-body2-elseif--else-bodyn" id="if-expr1-then-body1-elseif-expr2-then-body2-elseif--else-bodyn"><h1>if <em>expr1</em> ?then? <em>body1</em> elseif <em>expr2</em> ?then? <em>body2</em> elseif ... ?else? ?<em>bodyN</em>?</h1></a>
<p>Tests a chain of one or more expressions, and executes the matching <em>body</em>,
which must be a script.  Returns the result of the last command executed in
the selected <em>body</em>.</p>
<p>Both the <code>then</code> and <code>else</code> keywords are optional.  The standard TCL
convention is to always omit the <code>then</code> keywords and to always
include the <code>else</code> keyword when there's an <code>else</code> clause.</p>
<a class="header" href="#examples-4" id="examples-4"><h2>Examples</h2></a>
<pre><code class="language-tcl">if {$x &gt; 0} {
    puts &quot;positive&quot;
}

if {$x &lt; 0} {
    puts &quot;negative&quot;
} else {
    puts &quot;non-negative&quot;
}

if {$x &gt; 0} {
    puts &quot;positive&quot;
} elseif {$x &lt; 0} {
    puts &quot;negative&quot;
} else {
    puts &quot;zero&quot;
}

set value [if {$x &gt; 0} {
    expr {$x + $y}   
} else {
    expr {$x - $y}   
}]
</code></pre>
<a class="header" href="#incr-varname-increment" id="incr-varname-increment"><h1>incr <em>varName</em> ?<em>increment</em>?</h1></a>
<p>Increments integer-valued-variable <em>varName</em> by the given <em>increment</em>, which defaults to 1.
If the variable is unset, it is set to the <em>increment</em>.  The command returns the incremented
value.</p>
<a class="header" href="#examples-5" id="examples-5"><h2>Examples</h2></a>
<pre><code class="language-tcl">unset a
incr a    ;# =&gt; 1
incr a    ;# =&gt; 2
incr a 3  ;# =&gt; 5

for {set a 1} {$a &lt; 10} {incr a} {
    ...
}
</code></pre>
<a class="header" href="#info-subcommand-arg-" id="info-subcommand-arg-"><h1>info <em>subcommand</em> ?<em>arg</em> ...?</h1></a>
<p>Returns information about the state of the Molt interpreter.</p>
<table><thead><tr><th> Subcommand                              </th><th> Description                                       </th></tr></thead><tbody>
<tr><td> <a href="#info-args-procname">info args</a>        </td><td> Names of procedure's arguments                    </td></tr>
<tr><td> <a href="#info-body-procname">info body</a>        </td><td> Gets procedure body                               </td></tr>
<tr><td> <a href="#info-cmdtype-command">info cmdtype</a>   </td><td> Queries a command's type                          </td></tr>
<tr><td> <a href="#info-commands">info commands</a>         </td><td> Names of all defined commands                     </td></tr>
<tr><td> <a href="#info-complete-command">info complete</a> </td><td> Is this string a syntactically complete command?  </td></tr>
<tr><td> <a href="#info-default-procname-arg-varname">info default</a> </td><td> A procedure argument's default value   </td></tr>
<tr><td> <a href="#info-exists-varname">info exists</a>     </td><td> Is this a variable in the current scope?          </td></tr>
<tr><td> <a href="#info-globals">info globals</a>           </td><td> Names of all variables in the global scope        </td></tr>
<tr><td> <a href="#info-locals">info locals</a>             </td><td> Names of all local variables in the current scope </td></tr>
<tr><td> <a href="#info-procs">info procs</a>               </td><td> Names of all defined procedures                   </td></tr>
<tr><td> <a href="#info-vars">info vars</a>                 </td><td> Names of all variables in the current scope       </td></tr>
</tbody></table>
<a class="header" href="#info-args-procname" id="info-args-procname"><h2>info args <em>procname</em></h2></a>
<p>Retrieves a list of the names of the arguments of the named procedure.  Returns an error
if the command is undefined or is a binary command.</p>
<p>For example,</p>
<pre><code class="language-tcl">% proc myproc {a b c} { ... }
% info args myproc
a b c
%
</code></pre>
<a class="header" href="#info-body-procname" id="info-body-procname"><h2>info body <em>procname</em></h2></a>
<p>Retrieves the body of the named procedure.  Returns an error if the command is undefined or
is a binary command.</p>
<p>For example,</p>
<pre><code class="language-tcl">% proc myproc {name} { puts &quot;Hello, $name&quot; }
% info body myproc
puts &quot;Hello, $name&quot;
%
</code></pre>
<a class="header" href="#info-cmdtype-command" id="info-cmdtype-command"><h2>info cmdtype <em>command</em></h2></a>
<p>Retrieves the named command's type, either <code>native</code> or <code>proc</code>.  The <em>command</em> is <code>native</code> if it's
implemented in Rust and <code>proc</code> if it's implemented as a TCL procedure.</p>
<pre><code class="language-tcl">% proc myproc {} { ... }
% info cmdtype set
native
% info cmdtype myproc
proc
%
</code></pre>
<p><strong>TCL Liens</strong>: Standard TCL defines a variety of other command types, e.g., slave interpreters,
interpreter aliases, objects, and so forth.  These will be added naturally if and when they are
added to Molt.</p>
<a class="header" href="#info-commands" id="info-commands"><h2>info commands</h2></a>
<p>Returns an unsorted list of the names of the commands defined in the interpreter,
including both binary commands and procedures.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<a class="header" href="#info-complete-command" id="info-complete-command"><h2>info complete <em>command</em></h2></a>
<p>Returns 1 if the command appears to be a complete Tcl command, i.e., it
has no unmatched quotes, braces, or brackets, and 0 otherwise.  REPLs can
use this to allow the user to build up a multi-line command.</p>
<p>For example,</p>
<pre><code class="language-tcl">% info complete { puts &quot;Hello, world!&quot; }
1
% info complete { puts &quot;Hello, world! }
0
%
</code></pre>
<a class="header" href="#info-default-procname-arg-varname" id="info-default-procname-arg-varname"><h2>info default <em>procname</em> <em>arg</em> <em>varname</em></h2></a>
<p>Retrieves the default value of procedure <em>procname</em>'s argument called <em>arg</em>.  If <em>arg</em> has
a default value, <code>info default</code> returns 1 and assigns the default value to the variable
called <em>varname</em>.  Otherwise, <code>info default</code> returns 0 and assigns the empty string to the
variable called <em>varname</em>.</p>
<p>The command throws an error if:</p>
<ul>
<li><em>procname</em> doesn't name a procedure</li>
<li>The procedure <em>procname</em> has no argument called <em>arg</em></li>
<li>The value can't be assigned to a variable called <em>varname</em>.</li>
</ul>
<p>In the following example, <code>myproc</code> has two arguments, <code>a</code> and <code>b</code>.  <code>a</code> has no default value;
<code>b</code> has the default value <code>Howdy</code>.</p>
<pre><code class="language-tcl">% proc myproc {a {b Howdy}} { ... }
% info default myproc a defvalue
0
% puts &quot;&lt;$defval&gt;&quot;
&lt;&gt;
% info default myproc b defvalue
1
% puts &quot;&lt;$defval&gt;&quot;
&lt;Howdy&gt;
%
</code></pre>
<a class="header" href="#info-exists-varname" id="info-exists-varname"><h2>info exists <em>varname</em></h2></a>
<p>Returns 1 if <em>varname</em> is the name of a variable or array element in the current scope, and
0 otherwise.</p>
<pre><code class="language-tcl">% set a 1
1
% set b(1) 1
1
% info exists a
1
% info exists b
1
% info exists c
0
% info exists b(1)
1
% info exists b(2)
0
</code></pre>
<a class="header" href="#info-globals" id="info-globals"><h2>info globals</h2></a>
<p>Returns an unsorted list of the names of all variables defined in the global scope.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<a class="header" href="#info-locals" id="info-locals"><h2>info locals</h2></a>
<p>Returns an unsorted list of the names of all local variables defined in the current scope, e.g.,
<code>proc</code> arguments and variables defined locally, but no variables brought in from other scopes
via <code>global</code> or <code>upvar</code>.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<a class="header" href="#info-procs" id="info-procs"><h2>info procs</h2></a>
<p>Returns an unsorted list of the names of the procedures defined in the interpreter,
omitting binary commands.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<a class="header" href="#info-vars" id="info-vars"><h2>info vars</h2></a>
<p>Returns an unsorted list of the names of all variables that are visible
in the current scope, whether global or local.</p>
<p><strong>TCL Liens</strong>: does not support filtering the list using a <code>glob</code>
pattern.</p>
<a class="header" href="#join-list-joinstring" id="join-list-joinstring"><h1>join <em>list</em> ?<em>joinString</em>?</h1></a>
<p>Joins the elements of a list into a string, including the <em>joinString</em>
in between each element.  If not given, the <em>joinString</em> defaults to
a single space character.</p>
<a class="header" href="#lindex-list-index-" id="lindex-list-index-"><h1>lindex <em>list</em> ?<em>index</em> ...?</h1></a>
<p>Returns an element from the <em>list</em>, indexing into nested lists.  The indices
may be represented as individual indices on the command line, or as a list
of indices.  Indices are integers from 0 to length - 1.  If an index is less
than 0 or greater than or equal to the list length, <code>lindex</code> will return
the empty string.</p>
<a class="header" href="#examples-6" id="examples-6"><h2>Examples</h2></a>
<pre><code class="language-tcl">lindex {a {b c d} e}        ;# &quot;a {b c d} e&quot;
lindex {a {b c d} e} 1      ;# &quot;b c d&quot;
lindex {a {b c d} e} 1 1    ;# &quot;c&quot;
lindex {a {b c d} e} {}     ;# &quot;a {b c d} e&quot;
lindex {a {b c d} e} {1 1}  ;# &quot;c&quot;
</code></pre>
<a class="header" href="#tcl-liens-3" id="tcl-liens-3"><h2>TCL Liens</h2></a>
<p>Indices in standard TCL may take several additional forms.  For example,
<code>end</code> indexes the last entry in the list; <code>end-1</code> indexes the next to last
entry, and so forth.  Molt doesn't yet support this.</p>
<a class="header" href="#list-arg-" id="list-arg-"><h1>list ?<em>arg</em> ...?</h1></a>
<p>Returns a list whose elements are the given arguments.  The list will
be in canonical list form.</p>
<a class="header" href="#llength-list" id="llength-list"><h1>llength <em>list</em></h1></a>
<p>Returns the length of the list.</p>
<a class="header" href="#proc-name-args-body" id="proc-name-args-body"><h1>proc <em>name</em> <em>args</em> <em>body</em></h1></a>
<p>Defines a procedure with the given <em>name</em>, argument list <em>args</em>, and
script <em>body</em>.  The procedure may be called like any built-in command.</p>
<p>The argument list, <em>args</em>, is a list of argument specifiers, each of
which may be:</p>
<ul>
<li>A name, representing a required argument</li>
<li>A list of two elements, a name and a default value, representing an
optional argument</li>
<li>The name <code>args</code>, representing any additional arguments.</li>
</ul>
<p>Optional arguments must follow required arguments, and <code>args</code> must
appear last.</p>
<p>When called, the procedure returns the result of the last command in the
body script, or the result of calling <a href="ref/./return.html"><code>return</code></a>, or an
error.</p>
<a class="header" href="#tcl-liens-4" id="tcl-liens-4"><h2>TCL Liens</h2></a>
<p>Molt does not support namespaces or namespace syntax in procedure names.</p>
<a class="header" href="#puts-string" id="puts-string"><h1>puts <em>string</em></h1></a>
<p>Outputs the <em>string</em> to standard output.</p>
<a class="header" href="#tcl-liens-5" id="tcl-liens-5"><h2>TCL Liens</h2></a>
<ul>
<li>Does not support <code>-nonewline</code></li>
<li>Does not support <code>?channelId?</code></li>
</ul>
<a class="header" href="#rename-oldname-newname" id="rename-oldname-newname"><h1>rename <em>oldName</em> <em>newName</em></h1></a>
<p>Renames the command called <em>oldName</em> to be <em>newName</em> instead.</p>
<p>Any command may be renamed in this way; it is a common TCL approach to wrap a command by
renaming it and defining a new command with the <em>oldName</em> that calls the old command at
its <em>newName</em>.</p>
<p>If the <em>newName</em> is the empty string, the command will be removed from the interpreter.</p>
<a class="header" href="#examples-7" id="examples-7"><h2>Examples</h2></a>
<pre><code class="language-tcl">proc myproc {} { ... }

# Rename the proc
rename myproc yourproc

# Remove the proc from the interpreter
rename yourproc &quot;&quot;
</code></pre>
<a class="header" href="#return-value" id="return-value"><h1>return ?<em>value</em>?</h1></a>
<p>Returns the given <em>value</em>, or the empty string if <em>value</em> is omitted.</p>
<a class="header" href="#tcl-liens-6" id="tcl-liens-6"><h2>TCL Liens</h2></a>
<ul>
<li>In TCL, <code>return</code> allows the caller to generate any valid TCL result code
(e.g., <code>break</code>) with complete and detailed control.  In Molt it only
provides the basic <code>return</code> semantics.</li>
</ul>
<a class="header" href="#set-varname-newvalue" id="set-varname-newvalue"><h1>set <em>varName</em> ?<em>newValue</em>?</h1></a>
<p>Sets variable <em>varName</em> to the <em>newValue</em>, returning the <em>newValue</em>.  If
<em>newValue</em> is omitted, simply returns the variable's existing value, or
returns an error if there is no existing value.</p>
<p>The <code>set</code> command operates in the current scope, e.g., in
<a href="ref/./proc.html"><code>proc</code></a> bodies it operates on the set of local variables.</p>
<p>See also: <a href="ref/./global.html"><code>global</code></a></p>
<a class="header" href="#tcl-liens-7" id="tcl-liens-7"><h2>TCL Liens</h2></a>
<ul>
<li>Molt does not support namespaces or namespace notation.</li>
</ul>
<a class="header" href="#time-command-count" id="time-command-count"><h1>time <em>command</em> ?<em>count</em>?</h1></a>
<p>Evaluates the given <em>command</em> the given number of times, or once if no count is specified,
timing each execution.  The average run time in microseconds is returned as a string,
&quot;<em>average</em> microseconds per iteration&quot;.</p>
<a class="header" href="#example-8" id="example-8"><h2>Example</h2></a>
<pre><code class="language-tcl">% time { mycommand } 1000
15 microseconds per iteration
%
</code></pre>
<a class="header" href="#unset--nocomplain----name-name-name" id="unset--nocomplain----name-name-name"><h1>unset ?-nocomplain? ?--? ?<em>name</em> <em>name</em> <em>name</em>...?</h1></a>
<p>Unsets one or more variables whose names are passed to the command.
It does not matter whether the variables actually exist or not.</p>
<p>The <code>-nocomplain</code> option is ignored.  The argument <code>--</code> indicates the
end of options; all arguments following <code>--</code> will be treated as variable
names whether they begin with a hyphen or not.</p>
<a class="header" href="#tcl-differences-1" id="tcl-differences-1"><h2>TCL Differences</h2></a>
<p>In standard TCL, it's an error to unset a variable that doesn't exist; the
command provides the <code>-nocomplain</code> option to cover this case. In Molt,
<code>unset</code> never complains; the <code>-nocomplain</code> option is provided only for
compatible with legacy TCL code.  (Per the TCL Core Team, the <code>-nocomplain</code>
option indicates, wherever it is found, that the original definition of the
command got the default behaviour wrong.)</p>
<a class="header" href="#while-test-command" id="while-test-command"><h1>while <em>test</em> <em>command</em></h1></a>
<p>The <code>while</code> command is a standard &quot;while&quot; loop, executing the <em>command</em> script just so
long as the <em>test</em> expression evaluates to true.</p>
<a class="header" href="#example-9" id="example-9"><h2>Example</h2></a>
<p>The following code will output the numbers from 1 to 10.</p>
<pre><code class="language-tcl">set i 0
while {$i &lt; 10} {
    puts &quot;i=[incr i]&quot;
}
</code></pre>
<a class="header" href="#embedding-molt" id="embedding-molt"><h1>Embedding Molt</h1></a>
<p>This chapter explains how to embed Molt in a Rust application.  There are several parts
to this:</p>
<ul>
<li>Creating a Molt interpreter</li>
<li><a href="embed/./commands.html">Defining application-specific Molt commands</a></li>
<li>Invoking the interpreter to <a href="embed/./eval.html">evaluate Molt commands and scripts</a></li>
</ul>
<p>An application may execute scripts for its own purposes and arbitrary scripts defined by
the user.  One common pattern is to define a <a href="embed/./shell.html">shell application</a> the user
may use to execute their own scripts using the application-specific command set.</p>
<p>It is also possible to define <a href="embed/./library.html">Molt library crate</a> that defines commands
for installation into an interpreter.</p>
<p>The initial step, creating a Molt interpreter, is trivially easy:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp;

let mut interp = Interp::new();

// Add application-specific commands
#}</code></pre></pre>
<p>This creates an interpreter containing the standard set of Molt commands.  Alternatively,
you can create a completely empty interpreter and add just the commands you want:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp;

let mut interp = Interp::empty();

// Add application-specific commands
#}</code></pre></pre>
<p>This is useful if you wish to use the Molt interpreter as a safe file parser.</p>
<p>Eventually there will be an API for adding specific standard Molt commands back into an empty
interpreter so that the application can create a custom command set (e.g., including
variable access and control structures but excluding file I/O), but that hasn't yet
been implemented.</p>
<p>We'll cover the remaining topics in the following sections.</p>
<a class="header" href="#the-molt-value-type" id="the-molt-value-type"><h1>The Molt <code>Value</code> Type</h1></a>
<p>The <code>Value</code> type is the standard representation in Rust of Molt values.  In the Tcl
language, &quot;everything is a string&quot;; which is to say, every value can be represented
as a string.  Many valuese.g., numbers and listsalso have a binary data representation,
but a single value can move from one binary data representation to another depending
on how it is used by the user.  Consider the following:</p>
<pre><code class="language-tcl">set x [expr {2 + 3}]  ;# It's the integer 5.
puts &quot;x=$x&quot;           ;# It's converted to a string.
set y [lindex $x 0]   ;# It's converted to a one-element list.
</code></pre>
<p>Initially, the variable <code>x</code> contains a <code>Value</code> with only a data representation, the
integer 5.  Then <code>puts</code> needs it as a string, and so the <code>Value</code> acquires a string
representation as well, but retains its integer representation.  Then <code>lindex</code> needs
to look at it as a list, so the string is parsed into a Molt list and the 0th element
is returned.  The integer representation is lost and replaced by the list
representation. The <code>Value</code> type manages all of these transformations internally, with the effect that string-to-binary and binary-to-string conversions happen only when
absolutely necessary.</p>
<p>Note: A <code>Value</code>'s string representation is never lost, once acquired: semantically,
<code>Values</code> are immutable.  The data transformations that go on under the hood are an
aid to performance, but in principle the value is unchanged.</p>
<a class="header" href="#creating-values" id="creating-values"><h2>Creating Values</h2></a>
<p><code>Values</code> can be created easily from a variety of kinds of input:</p>
<pre><code>let a = Value::from(&quot;abc&quot;);                              // &amp;str
let b = Value::from(&quot;def&quot;.to_string());                  // String
let c = Value::from(123);                                // MoltInt (i64)
let d = Value::from(45.67);                              // MoltFloat (f64)
let e = Value::from(true);                               // bool
let f = Value::from(&amp;[Value::from(1), Value::from(2)]);  // &amp;[Value]
</code></pre>
<p>And in fact, a <code>Value</code> can contain any Rust type that supports the <code>Display</code>,
<code>Debug</code>, and <code>FromStr</code> types via the <code>Value::from_other</code> method.  Such types are
called &quot;external types&quot; in the Molt documentation set.</p>
<a class="header" href="#cloning-values" id="cloning-values"><h2>Cloning Values</h2></a>
<p>Because <code>Values</code> are immutable, they have been designed to be cheaply and easy cloned
with reference counting via the standard <code>Rc</code> type.</p>
<a class="header" href="#retrieving-data-from-values" id="retrieving-data-from-values"><h2>Retrieving Data from Values</h2></a>
<p>It is always possible to retrieve a <code>Value</code>'s data as a string:</p>
<pre><code>let value = Value::from(5);
let text: String = value.to_string();
assert_eq!(&amp;text, &quot;5&quot;);
</code></pre>
<p>The <code>to_string</code> method creates a brand new <code>String</code> in the usual way; it is usually better to
use <code>as_str</code>, which returns an <code>&amp;str</code>:</p>
<pre><code>let value = Value::from(5);
let text = value.as_str();
assert_eq!(text, &quot;5&quot;);
</code></pre>
<p>It is also possible to retrieve data representations; but since this isn't guaranteed to
work the relevant methods all return <code>Result&lt;_,ResultCode&gt;</code>.  (See
<a href="embed/./molt_result.html">The <code>MoltResult</code> type</a> for a discussion of <code>ResultCodes</code>.)  For
example,</p>
<pre><code>let value = Value::from(&quot;123&quot;);
let x = value.as_int()?;
assert_eq!(x, 123);
</code></pre>
<a class="header" href="#retrieving-values-of-external-types" id="retrieving-values-of-external-types"><h2>Retrieving Values of External Types</h2></a>
<p>Values of external types can be retrieved as well using the <code>Value::as_copy</code> or
<code>Value::as_other</code> method, depending on whether the type implements the <code>Copy</code>
trait.  These are different than their peers, in that they return <code>Option&lt;T&gt;</code>
and <code>Option&lt;Rc&lt;T&gt;&gt;</code> rather than <code>Result&lt;T,ResultCode&gt;</code> or <code>Result&lt;Rc&lt;T&gt;,ResultCode&gt;</code>.
The reason is that Molt doesn't know what the appropriate
error message should be when it finds a value it can't convert into the external
type <code>T</code> and so returns <code>None</code>, leaving the error handling up to the client.</p>
<p>For this reason, when using an external type <code>MyType</code> with Molt it is usual to define a
function that converts a <code>Value</code> to a <code>Result&lt;MyType,ResultCode&gt;</code>.  If <code>MyType</code> is an
enum, for example, you might write this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl MyType {
    /// A convenience: retrieves the enumerated value, converting it from
    /// `Option&lt;MyType&gt;` into `Result&lt;MyType,ResultCode&gt;`.
    pub fn from_molt(value: &amp;Value) -&gt; Result&lt;Self, ResultCode&gt; {
        if let Some(x) = value.as_copy::&lt;MyType&gt;() {
            Ok(x)
        } else {
            Err(ResultCode::Error(Value::from(&quot;Not a MyType string&quot;)))
        }
    }
}
#}</code></pre></pre>
<a class="header" href="#the-moltresult-type" id="the-moltresult-type"><h1>The MoltResult Type</h1></a>
<p><code>MoltResult</code> is Molt's standard <code>Result&lt;T,E&gt;</code> type; it is defined as</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub type MoltResult = Result&lt;Value, ResultCode&gt;;
#}</code></pre></pre>
<p>The <code>Value</code> type is described in the <a href="embed/./molt_value.html">previous section</a>; by default, many
Molt methods and functions return <code>Value</code> on success.</p>
<p>The <code>ResultCode</code> is more complicated, as it is used to pass not only errors but also
to manage control flow.  It is defined as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Eq, PartialEq, Clone, Debug)]
pub enum ResultCode {
    Error(Value),
    Return(Value),
    Break,
    Continue,
}
#}</code></pre></pre>
<p>In addition to a normal <code>Ok</code> result, a Molt function, method, or command can return:</p>
<ul>
<li>
<p><code>ResultCode::Error(msg)</code>, where <code>msg</code> is an error message; this indicates that
something has thrown an error.</p>
</li>
<li>
<p><code>ResultCode::Return(value)</code>, which indicates that the Molt code has called the
<code>return</code> command; the <code>value</code> is the returned value.  Molt procedures, defined using
the <code>proc</code> command, will catch this and return <code>value</code> as the value of the procedure.</p>
</li>
<li>
<p><code>ResultCode::Break</code> and <code>ResultCode::Continue</code> are returned by the <code>break</code> and
<code>continue</code> commands and control loop execution in the usual way.</p>
</li>
</ul>
<a class="header" href="#molt_ok-and-molt_err" id="molt_ok-and-molt_err"><h2><code>molt_ok!</code> and <code>molt_err!</code></h2></a>
<p>Application-specific Rust code will usually only use <code>Ok(value)</code> and
<code>Err(ReturnCode::Error(value))</code>. Since these two cases pop up so often,
Molt provides a couple of macros to make them easier: <code>molt_ok!</code> and <code>molt_err!</code>.</p>
<p><code>molt_ok!</code> takes one or more arguments and converts them into an <code>Ok(Value)</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Returns the empty result.
return molt_ok!();

// Returns its argument as a Value (if Molt knows how to convert it)
return molt_ok!(5);

// A plain Value is OK to.
return molt_ok!(Value::from(5));

// Returns a formatted string as a Value using a Rust `format!` string.
return molt_ok!(&quot;The answer is {}.&quot;, x);
#}</code></pre></pre>
<p><code>molt_err!</code> works just the same way, but returns <code>Err(ReturnCode::Err(Value))</code>.</p>
<pre><code>if x &gt; 5 {
    return molt_err!(&quot;value is out of range: {}&quot;, x);
}
</code></pre>
<a class="header" href="#defining-commands" id="defining-commands"><h1>Defining Commands</h1></a>
<p>At base, a Molt command is a Rust function that performs some kind of work and optionally
returns a value in the context of a specific Rust interpreter.  There are two ways an
application (or library crate) can define application-specific Rust commands:</p>
<ul>
<li>As a Rust <code>CommandFunc</code> function</li>
<li>As a Molt procedure, or <code>proc</code>.</li>
</ul>
<a class="header" href="#commandfunc-commands" id="commandfunc-commands"><h2><code>CommandFunc</code> Commands</h2></a>
<p>A <code>CommandFunc</code> command is any Rust function that implements <code>CommandFunc</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub type CommandFunc = fn(&amp;mut Interp, ContextID, &amp;[Value]) -&gt; MoltResult;
#}</code></pre></pre>
<p>For example, here's a simple command that takes one argument and returns it
unchanged.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn cmd_ident(_interp: &amp;mut Interp, _context_id: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 2, 2, &quot;value&quot;)?;

    molt_ok!(argv[1].clone())
}
#}</code></pre></pre>
<p>The <code>argv</code> vector contains the arguments to the command, beginning with the
command's name.  The <code>check_args</code> method verifies that the command has the right
number of arguments, and returns the standard Tcl error message if not.  Finally,
it uses <code>molt_ok!</code> to return its first argument.</p>
<p>Install this command into the interpreter using the <code>Interp::add_command</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
interp.add_command(&quot;ident&quot;, cmd_ident);
#}</code></pre></pre>
<a class="header" href="#commandfunc-commands-with-context" id="commandfunc-commands-with-context"><h2><code>CommandFunc</code> Commands with Context</h2></a>
<p>A normal <code>CommandFunc</code> is useful when extending the Molt language itself; but
application-specific commands need to manipulate the application and its data.  In this case,
add the required data to the interpreter's <em>context cache</em>.  The cached data can be retrieved,
used, and mutated by commands tagged with the relevant context ID.</p>
<p>The context cache is a hash map that allows the interpreter to keep arbitrary data and make
it available to commands. The usual pattern is like this:</p>
<ul>
<li>
<p>The application defines a type containing the data the command (or commands) requires.
We'll call it <code>AppContext</code> for the purpose of this example.</p>
</li>
<li>
<p>The application saves an instance of <code>AppContext</code> into the context cache, retrieving a
<code>ContextID</code>.</p>
</li>
<li>
<p>The application includes the <code>ContextID</code> when adding the command to the interpreter.</p>
</li>
<li>
<p>The command retrieves the <code>AppContext</code> as a mutable borrow.</p>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">// The AppContext
struct AppContext { text: String }

// The Command
fn cmd_whatsit(interp: &amp;mut Interp, context_id: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 2, 2, &quot;value&quot;)?;

    let ctx = interp.context::&lt;AppContext&gt;(context_id);

    // Append the first argument's string rep to the
    // AppContext struct's text field.
    ctx.text.push_str(argv[1].as_str());

    molt_ok!()
}

// Registering the command
fn main() {
    let interp = Interp::new();
    let id = interp.save_context(AppContext::new());

    interp.add_context_command(&quot;whatsit&quot;, cmd_whatsit, id);

    ...
}
</code></pre></pre>
<p>The saved <code>AppContext</code> will be dropped automatically if the <code>whatsit</code> command is
removed from the interpreter.</p>
<a class="header" href="#commands-with-shared-context" id="commands-with-shared-context"><h2>Commands with Shared Context</h2></a>
<p>Any number of Molt commands can share a single cached context struct:</p>
<pre><code>    let interp = Interp::new();
    let id = interp.save_context(AppContext::new());

    interp.add_context_command(&quot;first&quot;, cmd_first, id);
    interp.add_context_command(&quot;second&quot;, cmd_second, id);
    interp.add_context_command(&quot;third&quot;, cmd_third, id);
    ...
</code></pre>
<p>The context struct will persist in the cache until the final command is removed (or, of
course, until the interpreter is dropped).</p>
<a class="header" href="#molt-objects" id="molt-objects"><h2>Molt Objects</h2></a>
<p>The standard way to represent an object in TCL is to define a command with attached
context data. The command's methods are implemented as subcommands.</p>
<p>The context cache supports this pattern trivially.  Define the object's instance variables
as a context struct, and define a command to create instances.</p>
<pre><code>// Instance Data
struct InstanceContext { text: String }

// Command to make an instance
fn cmd_make(interp: &amp;mut Interp, _: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 2, 2, &quot;name&quot;)?;

    let id = interp.save_context(InstanceContext::new());

    interp.add_context_command(argv[1].as_str(), cmd_instance, id);

    molt_ok!()
}

// Instance Command
fn cmd_instance(interp: &amp;mut Interp, _: ContextID, argv: &amp;[Value]) -&gt; MoltResult {
    check_args(1, argv, 2, 0, &quot;subcommand ?args...?&quot;)?;

    // Get the context
    let ctx = interp.context::&lt;AppContext&gt;(context_id);

    // Do stuff based on argv[1], the subcommand.
    ...
}

// Registering the command
fn main() {
    let interp = Interp::new();

    interp.add_command(&quot;make&quot;, cmd_make);

    ...
}
</code></pre>
<p>Then, in Molt code you can create an object called <code>fred</code>, use its methods, and then
destroy it by renaming it to the empty string.</p>
<pre><code class="language-tcl">% make fred
% fred do_something 1 2 3
...
% rename fred &quot;&quot;
</code></pre>
<a class="header" href="#molt-procedures" id="molt-procedures"><h2>Molt Procedures</h2></a>
<p>A Molt procedure is a routine coded in Tcl and defined using the <code>proc</code> command. A
crate can compile Tcl procedures into itself using the <code>include_str!</code> macro.  Start
by defining a script that defines the required procedure, say, <code>procs.tcl</code>, and put it
in the crate's <code>src/</code> folder adjacent to the Rust file that will load it.  The Rust
file can then do this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut interp = Interp::new();

match interp.eval(include_str!(&quot;commands.tcl&quot;)) {
    Err(ResultCode::Error(msg)) =&gt; {
        panic!(&quot;Couldn't load procs.tcl: {}&quot;, msg);
    }
    _ =&gt; ()
}
#}</code></pre></pre>
<a class="header" href="#evaluating-molt-code" id="evaluating-molt-code"><h1>Evaluating Molt Code</h1></a>
<p>An application can evaluate Molt code in several ways:</p>
<ul>
<li>
<p>Use one of the <code>molt::Interp::eval</code> or <code>molt::Interp::eval_value</code> to evaluate an
individual Molt command or script.</p>
</li>
<li>
<p>Use the <code>molt::Interp::eval_body</code> method to evaluate a Molt script that is the body
of a control structure.</p>
</li>
<li>
<p>Use the <code>molt::expr</code> function to evaluate a Molt expression, returning a Molt <code>Value</code>,
or <code>molt::expr_bool</code>, <code>molt::expr_int</code>, and <code>molt::expr_float</code> for results of specific
types.</p>
</li>
<li>
<p>Use the <code>molt_shell::repl</code> function to provide an interactive REPL to the user.</p>
</li>
<li>
<p>Use the <code>molt_shell::script</code> function to evaluate a script file (or just load the script's
content and pass it to <code>molt::Interp::eval</code>).</p>
</li>
</ul>
<a class="header" href="#evaluating-scripts-with-eval" id="evaluating-scripts-with-eval"><h2>Evaluating Scripts with <code>eval</code></h2></a>
<p>The <code>molt::Interp::eval</code> method evaluates a string as a Molt script and returns the result,
which will always be either <code>Ok(Value)</code> or <code>Err(ResultCode:Error(Value))</code>. (Other result
codes are translated into <code>Ok</code> or <code>Err</code> as appropriate.  See
<a href="embed/./molt_result.html">The <code>MoltResult</code> Type</a> for details.)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp;
use molt::types::*;

let mut interp = Interp::new();

...

let value: Value = interp.eval(&quot;...some Molt code...&quot;)?;
#}</code></pre></pre>
<p>The explicit <code>Value</code> type declaration is included for clarity.</p>
<p>The <code>molt::Interp::eval_value</code> method has identical semantics, but evaluates the string
representation of a molt <code>Value</code>. In this case, the <code>Value</code> will cache the parsed internal
form of the script to speed up subsequent evaluations.</p>
<a class="header" href="#evaluating-scripts-with-eval_body" id="evaluating-scripts-with-eval_body"><h2>Evaluating Scripts with <code>eval_body</code></h2></a>
<p>The <code>molt::Interp::eval_body</code> method is used when implementing control structures, as it
gives access to the entire set of <code>MoltResult</code> return codes.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp;
use molt::types::*;

fn my_cmd(interp: &amp;mut Interp, argv: &amp;[Value]) -&gt; MoltResult {
    // Get a Molt script to evaluate, e.g., a loop body:
    let body = argv[1];

    ...

    // Assume we're implementing some kind of loop.
    loop {
        ...

        // Evaluate the loop body
        let result = interp.eval_body(body.as_str());

        match result {
            Ok(value) =&gt; {
                // normal OK result.  What you do with it depends on the
                // control structure. There's probably nothing special to do
                // here; we'll just go on with the next iteration of the loop.
                continue;
            }
            Err(ResultCode::Err(msg)) =&gt; {
                // An error.  Control structures should usually let this
                // propagate.
                return result;
            }
            Err(ResultCode::Return(value)) =&gt; {
                // The code called the `return` command.  Let this propagate to
                // return from the enclosing `proc`.
                return result;
            }
            Err(ResultCode::Break) =&gt; {
                // The code called the `break` command.  If this function is
                // implementing a loop, it should return `Ok` to break out of
                // the loop; otherwise, let the `Break` propagate to break out
                // of the enclosing loop. Since this is a loop,  
                // break and return `Ok'
                break;
            }
            Err(ResultCode::Continue) =&gt; {
                // The code called the `continue` command.  If this function is
                // implementing a loop, this should continue on to the next
                // iteration of the loop after doing any necessary clean-up.  
                // Otherwise, let it propagate to continue in the enclosing loop.
                // Here, we're implementing a loop.
                continue;
            }
        }

        ...
    }

    ...
    // It's a loop, which normally returns an empty result.
    molt_ok!()
}
#}</code></pre></pre>
<p>See <a href="embed/./molt_result.html">The <code>MoltResult</code> Type</a> for more information.</p>
<p>The explicit <code>Value</code> type declaration is included for clarity.</p>
<a class="header" href="#evaluating-expressions-with-expr-and-expr_bool" id="evaluating-expressions-with-expr-and-expr_bool"><h2>Evaluating Expressions with <code>expr</code> and <code>expr_bool</code>.</h2></a>
<p>Evaluating Molt expressions is similar.  To get any expression result (usually a
numeric or boolean <code>Value</code>), use the <code>Interp::expr</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp;
use molt::types::*;
use molt::expr;

let mut interp = Interp::new();

...

let value: Value = interp.expr(&quot;1 + 1&quot;)?;
#}</code></pre></pre>
<p>Use <code>Interp::expr_bool</code> when a specifically boolean result is wanted:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let flag: bool = interp.expr_bool(&quot;1 == 1&quot;)?;
#}</code></pre></pre>
<p>(See the <a href="embed/../ref/expr.html"><code>expr</code></a> command reference for more about Molt expressions.)</p>
<a class="header" href="#providing-an-interactive-repl" id="providing-an-interactive-repl"><h2>Providing an interactive REPL</h2></a>
<p>An interactive user shell or &quot;REPL&quot; (Read-Eval-Print-Loop) can be a great convenience
when developing and debugging application scripts; it can also be useful tool for
administering server processes.  To provide an interactive shell, use
the <code>molt_shell::repl</code> function.</p>
<pre><code>use molt::Interp;

// FIRST, create and initialize the interpreter.
let mut interp = Interp::new();

// NOTE: commands can be added to the interpreter here.

// NEXT, invoke the REPL.
molt_shell::repl(&amp;mut interp, &quot;% &quot;);
</code></pre>
<a class="header" href="#evaluating-script-files" id="evaluating-script-files"><h2>Evaluating Script Files</h2></a>
<p>To execute a user script file, one can load the file contents and use <code>Interp::eval</code> in
the normal way, or use the <code>molt_shell::script</code> function.  A shell application might
execute a user script as follows.  Any errors are output to the console.</p>
<pre><code>use molt::Interp;
use std::env;

// FIRST, get the command line arguments.
let args: Vec&lt;String&gt; = env::args().collect();

// NEXT, create and initialize the interpreter.
let mut interp = Interp::new();

// NOTE: commands can be added to the interpreter here.

// NEXT, evaluate the file, if any.
if args.len() &gt; 1 {
    molt_shell::script(&amp;mut interp, &amp;args[1..]);
} else {
    eprintln!(&quot;Usage: myshell filename.tcl&quot;);
}
</code></pre>
<a class="header" href="#custom-shells" id="custom-shells"><h1>Custom Shells</h1></a>
<p>A custom Molt shell is simply an application that:</p>
<ul>
<li>Creates a Molt <code>interp</code></li>
<li>Adds any desired commands by the methods described in the previous section</li>
<li>Passes the <code>interp</code> to <code>molt_shell::repl</code> (for an interactive shell)</li>
<li>Passes the <code>interp</code> and a file to <code>molt_shell::script</code></li>
</ul>
<p>The <a href="https://github.com/wduquette/molt-sample">sample Molt application</a> provides a full
example; here's a sketch:</p>
<pre><code>fn main() {
    use std::env;

    // FIRST, get the command line arguments.
    let args: Vec&lt;String&gt; = env::args().collect();

    // NEXT, create and initialize the interpreter.
    let mut interp = Interp::new();

    // NOTE: commands can be added to the interpreter here, e.g.,

    // Add a single module
    interp.add_command(&quot;hello&quot;, cmd_hello);

    // Install a Molt extension crate
    molt_sample::install(&amp;mut interp).expect(&quot;Could not install.&quot;);

    // NEXT, evaluate the file, if any.
    if args.len() &gt; 1 {
        molt_shell::script(&amp;mut interp, &amp;args[1..]);
    } else {
        molt_shell::repl(&amp;mut interp, &quot;% &quot;);
    }
}

pub fn cmd_hello(_interp: &amp;mut Interp, argv: &amp;[Value]) -&gt; MoltResult {
    // Correct number of arguments?
    check_args(1, argv, 2, 2, &quot;name&quot;)?;

    println!(&quot;Hello, {}&quot;, argv[1].as_str());
    molt_ok!()
}
</code></pre>
<a class="header" href="#molt-library-crates" id="molt-library-crates"><h1>Molt Library Crates</h1></a>
<p>A Molt library crate is simply a Rust crate that can install commands into a
Molt interpreter using any of the methods described in this chapter.<br />
For example, a crate might provide an <code>install</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use molt::Interp

pub fn install(interp: &amp;mut Interp) {
    interp.add_command(&quot;mycommand&quot;, mycommand);
    ...
}
#}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
